{"meta":{"title":"耀的个人站","subtitle":"","description":"个人博客站点","author":"zhaoyao","url":"https://giscloud.ltd","root":"/"},"pages":[{"title":"分类","date":"2021-12-30T13:22:38.600Z","updated":"2021-10-09T06:21:59.118Z","comments":false,"path":"categories/index.html","permalink":"https://giscloud.ltd/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-30T13:22:38.597Z","updated":"2021-10-10T08:47:29.387Z","comments":false,"path":"about/index.html","permalink":"https://giscloud.ltd/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2021-12-30T13:22:38.601Z","updated":"2021-10-09T06:21:59.120Z","comments":false,"path":"tags/index.html","permalink":"https://giscloud.ltd/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"openstack实战","date":"2021-12-30T13:26:19.842Z","updated":"2021-12-30T09:03:25.040Z","comments":true,"path":"2021/12/30/openstack实战/","link":"","permalink":"https://giscloud.ltd/2021/12/30/openstack%E5%AE%9E%E6%88%98/","excerpt":"","text":"OpenStack-T版搭建笔记概览OpenStack 项目是一个开源的云计算平台，支持所有类型的云环境。该项目的目标是简单的实现，大规模的可扩展性，以及丰富的功能集。来自世界各地的云计算专家为该项目做出了贡献。 OpenStack 通过各种互补的服务提供了一种基础设施即服务(IaaS)解决方案。每个服务都提供了一个应用程序编程接口(API) ，以促进这种集成。根据您的需要，您可以安装部分或全部服务。 本指南使用适合具有足够 Linux 经验的 OpenStack 新用户的功能示例体系结构，介绍了主要 OpenStack 服务的分步部署。本指南并不打算用于生产系统安装，而是为了学习 OpenStack 而创建一个最基本的概念验证。 在熟悉这些 OpenStack 服务的基本安装、配置、操作和故障排除之后，您应该考虑使用生产体系结构进行部署的以下步骤: 确定并实现必要的核心和可选服务，以满足性能和冗余需求。 使用防火墙、加密和服务策略等方法提高安全性。 实现一个部署工具，如 Ansible、Chef、Puppet或Salt，以自动化生产环境的部署和管理。 OpenStack服务OpenStack project navigator允许您浏览构成OpenStack体系结构的OpenStack服务。服务按照服务类型和发布系列分类。 架构概念架构下图显示了 OpenStack 服务之间的关系: 逻辑架构要设计、部署和配置 OpenStack，管理员必须了解逻辑架构。 如概念架构所示，OpenStack由几个独立的部分组成，称为OpenStack服务。所有服务都通过公共认证服务进行身份验证。各个服务通过公共APIs相互交互，但需要特权管理员命令的服务除外。 在内部，OpenStack服务由几个进程组成。所有服务都至少有一个API进程，用于侦听API请求、预处理它们并将它们传递到服务的其他部分。除了Identity服务之外，实际工作由不同的流程完成。 对于一个服务的进程之间的通信，使用AMQP消息代理。服务的状态存储在数据库中。在部署和配置OpenStack云时，您可以选择几种消息代理和数据库解决方案，比如RabbitMQ、MySQL、MariaDB和SQLite。 用户可以通过Horizon Dashboard实现的基于web的用户界面、命令行客户端以及通过浏览器插件或curl等工具发出API请求来访问OpenStack。对于应用程序，有several SDKs可用。最终，所有这些访问方法都会向各种OpenStack服务发出REST API调用。 下图显示了OpenStack云最常见但不是唯一可能的架构: 架构示例本示例体系结构需要至少两个节点(主机)来启动基本虚拟机(VM)或实例。块存储和对象存储等可选服务需要额外的节点。 本指南中使用的示例体系结构是最小配置，不适用于生产系统安装。它旨在提供一个最低限度的概念证明，以便学习 OpenStack。有关为特定用例创建体系结构，或者如何确定需要哪种体系结构的信息，请参阅体系结构设计指南。https://docs.openstack.org/arch-design/ 这个示例体系结构与最小生产体系结构的区别如下: 网络代理驻留在控制器节点而不是一个或多个专用网络节点上。 自助服务网络的overlay(隧道)流量经过管理网络，而不是专用网络。 有关生产体系结构的详细信息, see the Architecture Design Guide, OpenStack Operations Guide, and OpenStack Networking Guide. 硬件要求： Controller：控制器节点运行 Identity 服务、Image服务、 Compute 的管理部分、 Networking 的管理部分、各种 Networking 代理和 Dashboard。它还包括支持服务，如 SQL 数据库、消息队列和网络时间协议(NTP)。 可选地，控制器节点运行块存储( Block Storage)、对象存储(Object Storage)、编排(Orchestration)和遥测服务 (Telemetry services)的部分。 Compute：计算节点运行 Compute（操作实例）的 hypervisor 部分。默认情况下，Compute 使用基于内核的 VM (KVM)管理程序。 计算节点还运行一个 Networking 服务代理，该代理将实例连接到虚拟网络，并通过安全组向实例提供防火墙服务。 您可以部署多个计算节点。每个节点至少需要两个网络接口。 Block Storage：可选的Block Storage节点包含多个磁盘，这些磁盘块为实例提供块存储和共享文件系统服务。 为简单起见，计算节点和此节点之间的服务通信使用管理网络。生产环境应该实现一个单独的存储网络，以提高性能和安全性。 可以部署多个块存储节点。每个节点至少需要一个网络接口。 Object Storage：可选的对象存储节点包含多个磁盘，这些磁盘(对象存储服务)用于存储帐户、容器和对象。 为简单起见，计算节点和此节点之间的服务通信使用管理网络。生产环境应该实现一个单独的存储网络，以提高性能和安全性。 此服务需要两个节点。每个节点至少需要一个网络接口。您可以部署两个以上的对象存储节点。 Networking：选择下列虚拟网络选项之一 联网方案1：Provider networks（提供商网络） Provider networks 选项以最简单的方式部署 OpenStack Networking 服务，主要是第二层(bridging/switching 桥接/交换)服务和VLAN网络分割。从本质上讲，它将虚拟网络与物理网络桥接起来，并依靠物理网络基础设施提供第三层(routing 路由)服务。此外，DHCP(Dynamic Host Configuration Protocol)服务为实例提供 IP 地址信息。 OpenStack 用户需要有关基础网络基础设施的更多信息，以创建一个虚拟网络来与基础设施完全匹配。 此选项缺乏对自助(私有)网络、第三层(路由)服务和高级服务(如 Load-Balancer-as-a-Service (LBaaS)和 FireWall-as-a-Service (FWaaS))的支持。如果您需要这些特性，可以考虑下面的自助服务网络选项。 联网方案1：Self-service networks（自助服务网络） 自助服务网络选项增加了提供者网络选项，增加了第3层(routing 路由)服务，这些服务使用overlay segmentation methods(如 Virtual Extensible LAN 服务(VXLAN))支持自助服务网络。本质上，它使用网络地址转换(NAT)将虚拟网络路由到物理网络。此外，此选项为LBaaS和FWaaS等高级服务提供了基础。 OpenStack 用户可以在不了解数据网络底层基础结构的情况下创建虚拟网络。如果是根据需要配置了layer-2 plug-in，那么还可以包括 VLAN 网络。 一、配置虚拟机与基本服务配置1.1、创建虚拟机controller文件→新建虚拟机→典型→稍后安装操作系统→Linux(版本centos 7 64位)→虚拟机名称：controller，位置（自定义）→最大磁盘大小（60G），选择‘将虚拟磁盘存储为单个文件’→一直下一步→编辑此虚拟机（设置内存：8GB，处理器：4，虚拟化引擎：虚拟化Intel VT -x/EPT或AMD-V/RVI，CD/DVD：选择Linux系统CentOS-7-x86_64-Minimal-1908.iso，再添加个网络适配器：仅主机模式，）→确定→开启虚拟机→设置语言（English）→设置时区（Asia、sahnghai）→设置磁盘分区（SYSTEM→INSTALLATION DESTINATION）→/boot sda1 200M，swap centos-swap 2048M，/ centos-root 57.8G(剩余的空间)→设置NETWORK &amp; HOSTNAME（这里的名称可以在进入系统后再设置）→设置开机开机root账号对应的密码→reboot 1.2、创建虚拟机compute文件→新建虚拟机→典型→稍后安装操作系统→Linux(版本centos 7 64位)→虚拟机名称：controller，位置（自定义）→最大磁盘大小（60G），选择‘将虚拟磁盘存储为单个文件’→一直下一步→编辑此虚拟机（设置内存：4GB，处理器：4，虚拟化引擎：虚拟化Intel VT -x/EPT或AMD-V/RVI，CD/DVD：选择Linux系统CentOS-7-x86_64-Minimal-1908.iso，再添加个网络适配器：仅主机模式，）→确定→开启虚拟机→设置语言（English）→设置时区（Asia、sahnghai）→设置磁盘分区（SYSTEM→INSTALLATION DESTINATION）→/boot sda1 200M，swap centos-swap 2048M，/ centos-root 57.8G(剩余的空间)→设置NETWORK &amp; HOSTNAME（这里的名称可以在进入系统后再设置）→设置开机开机root账号对应的密码→reboot 1.3、controller节点上的基本服务配置环境配置参考：https://docs.openstack.org/install-guide/environment.html 1.3.1、配置controller节点网卡123456789101112131415## IP地址、子网掩码、网关要根据自己的情况设置## 配置controller网卡ifcfg-ens33## 配置完成后可以使用xshell等软件进行远程ssh连接# 进入/etc/sysconfig/network-scripts/ifcfg-ens33进行配置vi /etc/sysconfig/network-scripts/ifcfg-ens33# 将配置文件中的内容显示在终端cat /etc/sysconfig/network-scripts/ifcfg-ens33# 打开网络接口 nmcli C up ens33# 配置完成后重启网络systemctl restart network# 查看IPip a# ping一下外网（如果ping不同可能是没有打开网络接口）ping baidu.com 1.3.2、关闭controller节点selinux和防火墙123456789101112131415161718192021222324## 关闭selinux# 方式一sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config# 方式二# 打开selinux配置文件vi /etc/selinux/config# 或者查看selinux配置文件cat /etc/selinux/config# 修改其中的SELINUX参数SELINUX=disabled# getenforce查看是否开启了SELinuxEnforcing #默认是开启的# setenforce 0 0： 切换成 permissive（宽容模式）# setenforce 1 1： 切换成 enforcing（强制模式）# 切换成宽容模式setenforce 0## 查看防火墙设置systemctl status firewalld# 关闭防火墙 &#x27;;&#x27;表示 &amp;&amp;systemctl stop firewalld; systemctl disable firewalld# 查看当前iptables规则(防火墙规则)# https://www.cnblogs.com/yyxianren/p/10910930.htmliptables -L 1.3.3、修改controller节点主机名称12345678# 修改controller节点主机名称hostnamectl set-hostname controller# 查看hostnamehostname# 查看iphostname -I# 重新登录logout 1.3.4、配置controller节点时间服务器为了使各节点之间的服务能够正常同步，可以安装NTP的实现器Chrony。建议将控制节点配置为引用更精确(较低层次)的服务器，并将其他节点配置为引用控制节点。 控制节点 12345678910111213# 1、安装Chrony包yum install chrony# 2、编辑chrony.conf文件，并根据环境的需要添加、更改或删除以下键vi /etc/chrony.conf# 2.1、 &quot;server NTP_SERVER iburst&quot;中将“NTP_SERVER”替换为更合适、更准确(级别较低)的NTP服务器的主机名或IP地址。该配置支持多个服务器密钥# &quot;server NTP_SERVER iburst&quot;替换为server ntp3.aliyun.com iburst# 2.2、为了使其他节点能够连接到控制器节点上的chrony守护进程，将这个key添加到前面提到的同一个chrony.conf文件中# 如果有必要，将10.0.0.0/24替换为您子网的描述# 将&quot;allow 192.168.0.0/16&quot;替换为所有节点都可以allow all# 2.3、设置即使没有与时间源同步，也可以提供时间最大机器数local stratum 10 12345678910111213# 3、配置完成后，重启chrony配置文件 d表示守护进程systemctl restart chronyd# 4、查看chronyd进程的状态systemctl status chronyd # 5、同步时间，同步之后date查看时间，看是否与互联网时间一致chronyc sources -v# 6、设置hosts解析,在hosts文件中添加controller、compute节点的host解析vi /etc/hostscontroller节点的IP controllercompute节点的IP compute# 7、设置hosts解析后，ping一下进行验证ping controllerping compute 1.3.5、安装Openstack源由于发行版时间表不同，发行版将OpenStack包作为发行版的一部分发布，或者使用其他方法发布。在所有节点上执行这些过程。 Note：此处描述的OpenStack包的设置需要在所有节点上完成:控制器、计算节点和块存储节点。 Warning：在进一步操作之前，您的主机必须包含可用于发行版的基本安装包的最新版本。 Note：禁用或删除任何自动更新服务，因为它们会影响OpenStack环境。 Warning：我们建议在使用RDO包时禁用EPEL，因为EPEL中的更新会破坏向后兼容性。或者，最好使用yum-versionlock插件钉住包版本。 启用OpenStack存储库 在CentOS上，extras存储库提供了支持OpenStack存储库的RPM。CentOS默认包含了额外的存储库，所以您可以简单地安装这个包来启用OpenStack存储库。对于CentOS8，您还需要启用PowerTools存储库。 安装Train release时，运行: 12345678910111213141516171819# 查看本地是否有openstack包yum list | grep openstack*# 安装Train release时，运行# 安装centos-release-openstack-train相关依赖包yum install centos-release-openstack-train -y# 安装完成后可以查看一下安装的库cd /etc/yum.repos.d/ll# 查看安装库的内核cat /etc/redhat-release# 查看节点系统内核uname -a# 升级（可选）yum upgrade# 相关的依赖包安装之后，需要用什么就安装相应的源# 为您的版本安装合适的OpenStack客户端yum install python-openstackclient -y# RHEL和CentOS默认启用SELinux。安装OpenStack -selinux包，实现OpenStack服务的安全策略自动管理yum install openstack-selinux -y 1.3.6、安装配置数据库多数OpenStack服务使用SQL数据库存储信息。数据库通常运行在控制节点上。本指南中的过程根据发行版使用MariaDB或MySQL。OpenStack服务还支持PostgreSQL等其他SQL数据库。 1234567891011121314151617181920212223# 1、控制节点安装数据库（安装数据库客户端、服务端以及python2-PyMySQL操作数据库的模块）yum install mariadb mariadb-server python2-PyMySQL -y# 2、创建并编辑/etc/my.cnf.d/openstack.cnf文件(备份/etc/my.cnf.d/现有配置文件)，完成如下操作:# 2.1、创建[mysqld]区域，并将bind-address key设置为控制节点的管理IP地址，以便其他节点通过管理网络访问。设置额外的键以启用有用的选项和UTF-8字符集vi /etc/my.cnf.d/openstack.cnf[mysqld]bind-address = 192.168.147.8default-storage-engine = innodbinnodb_file_per_table = onmax_connections = 4096collation-server = utf8_general_cicharacter-set-server = utf8# 3、完成安装# 3.1、启动数据库服务，并将其配置为系统启动时自动启动systemctl enable mariadb.servicesystemctl start mariadb.service# 3.2、运行mysql_secure_installation脚本初始化数据库服务。为数据库root帐户设置密码（回车 y 设置密码:123456 y n y y ）mysql_secure_installation# 4、验证数据库是否可以登录mysql -pquit 1.3.7、消息队列服务OpenStack通过消息队列来协调各服务之间的操作和状态信息。消息队列服务通常运行在控制节点上。OpenStack支持RabbitMQ、Qpid、ZeroMQ等消息队列服务。但是，大多数封装OpenStack的发行版都支持特定的消息队列服务。本指南实现了RabbitMQ消息队列服务，因为大多数发行版都支持它。 消息队列运行在控制节点上。 12345678910111213141516171819202122# 1、安装rabbitmq-server服务包yum install rabbitmq-server -y# 2、启动消息队列服务，并将其配置为在系统启动时自动启动systemctl enable rabbitmq-server.servicesystemctl start rabbitmq-server.service# 3、添加openstack用户，用合适的密码替换RABBIT_PASS（设置rabbitmq openstack用户密码：openstack123）# rabbitmqctl add_user openstack RABBIT_PASSrabbitmqctl add_user openstack openstack123# 4、允许openstack用户进行配置、写、读访问rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;# 5、可以通过命令来查rabbitmq的帮助rabbitmqctl -hrabbitmqctl -h | grep userrabbitmqctl list_users# 查看rabbitmq需要启动的服务(需要启动rabbitmq_management、rabbitmq_management_agent)rabbitmq-plugins list# 启动rabbitmq_management和rabbitmq_management_agent服务rabbitmq-plugins enable rabbitmq_management rabbitmq_management_agent# 6、启动完成后看看是否可以访问rabbitmqss -tnl # 查看服务端口hostname -I # 查当前节点（控制节点）的IP# 7、在浏览器中访问： http://192.168.147.8:15672/ 1.3.8、缓存服务服务的身份验证机制使用Memcached来缓存令牌。memcached服务通常运行在控制节点上。对于生产部署，建议启用防火墙、身份验证和加密的组合来保护它。 12345678910111213# 1、安装memcached、python-memcached包yum install memcached python-memcached -y# 2、编辑/etc/sysconfig/memcached文件，完成如下操作# 配置服务使用控制节点的管理IP地址。使其他节点可以通过管理网络访问vi /etc/sysconfig/memcachedCACHESIZE=&quot;1024&quot;OPTIONS=&quot;-l 127.0.0.1,::1,controller&quot;# 3、完成安装# 启动Memcached服务，并将其配置为在系统启动时自动启动systemctl enable memcached.servicesystemctl start memcached.service# 4、查看缓存服务状态systemctl status memcached.service 1.4、compute节点上的基本服务配置1.4.1、配置compute节点网卡 1.4.2、关闭compute节点selinux和防火墙1sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config; systemctl stop firewalld; systemctl disable firewalld 1.4.3、修改compute节点主机名称12345678# 修改compute节点主机名称hostnamectl set-hostname compute# 查看hostnamehostname# 查看iphostname -I# 重新登录logout 1.4.4、配置compute节点时间服务器其它节点（compute节点） 1234567891011121314151617181920# 1、设置hosts解析,在hosts文件中添加controller、compute节点的host解析vi /etc/hosts# 添加controller、compute节点的host解析controller节点的IP controllercompute节点的IP compute# 2、设置hosts解析后，ping一下进行验证ping controllerping compute# 3、安装Chrony包yum install chrony# 4.1、编辑chrony.conf文件，并根据环境的需要添加、更改或删除以下键vi /etc/chrony.conf# 4.2、从节点（其它节点）根据控制节点来设置，因为控制节点已经做了hosts解析，所以直接填主机的名称即可。其它不用设置server controller iburst# 5、配置完成后，重启chrony配置文件 d表示守护进程systemctl restart chronyd# 6、同步时间chronyc sources -v# 7、date查看时间，与互联网时间比较date 1.4.5、安装Openstack源1234567891011121314151617# 查看本地是否有openstack包yum list | grep openstack*# 安装Train release时，运行# 安装centos-release-openstack-train相关依赖包yum install centos-release-openstack-train -y# 安装完成后可以查看一下安装的库cd /etc/yum.repos.d/ll# 查看安装库的内核cat /etc/redhat-release# 查看节点系统内核uname -a# 升级（可选）yum upgrade# 相关的依赖包安装之后，需要用什么就安装相应的源# 比如安装OpenStack客户端以及安装OpenStack -selinux包，实现OpenStack服务的安全策略自动管理yum install python-openstackclient openstack-selinux -y 二、认证服务—keystone安装OpenStack系统由几个关键服务组成，分别安装。这些服务根据您的云需求协同工作，包括计算、身份、网络、图像、块存储、对象存储、遥测、编排和数据库服务（Compute, Identity, Networking, Image, Block Storage, Object Storage, Telemetry, Orchestration, and Database services）。您可以单独安装这些项目中的任何一个，并将它们配置为独立的或连接的实体。 此章节介绍在控制节点上安装和配置OpenStack Identity服务keystone的操作步骤。出于可伸缩性的目的，此配置部署了Fernet令牌和Apache HTTP服务器来处理请求。 本指南将向您展示如何使用 Red Hat Enterprise Linux或CentOS上可用的包安装 Keystone，以及如何通过 RDO (远程数据对象)存储库安装它的衍生产品。包括配置选项和示例配置文件的说明。 2.1、认证服务概述OpenStack Identity 服务为管理身份验证、授权和服务目录提供了一个集成点。 Identity 服务通常是用户交互的第一个服务。一旦经过身份验证，最终用户可以使用他们的身份访问其他 OpenStack 服务。同样，其他 OpenStack 服务利用 Identity 服务来确保用户是他们所说的那个人，并发现部署中其他服务的位置。Identity 服务还可以与一些外部用户管理系统(如 LDAP)集成。 用户和服务可以通过使用由 Identity 服务管理的服务目录来定位其他服务。顾名思义，服务目录是 OpenStack 部署中可用服务的集合。每个服务可以有一个或多个端点，每个端点可以是三种类型之一: 管理、内部或公共。在生产环境中，出于安全原因，不同的端点类型可能驻留在公开给不同类型用户的独立网络中。例如，公共 API 网络可能在互联网上可见，因此客户可以管理他们的云。管理 API 网络可能仅限于组织内管理云基础设施的运营商。内部 API 网络可能仅限于包含 OpenStack 服务的主机。另外，OpenStack 支持多个区域的可伸缩性。为简单起见，本指南使用所有端点类型和缺省 RegionOne 区域的管理网络。在 Identity 服务中创建的区域、服务和端点组成了部署的服务目录。部署中的每个 OpenStack 服务都需要一个服务条目，并在 Identity 服务中存储相应的端点。这些都可以在安装和配置了 Identity 服务之后完成。 Identity 服务包含以下组件: Server：集中式服务器使用 RESTful 接口提供身份验证和授权服务。 Drivers：驱动程序或服务后端集成到集中服务器。它们用于访问 OpenStack 外部存储库中的身份信息，并且可能已经存在于部署 OpenStack 的基础结构中(例如，SQL 数据库或 LDAP 服务器)。 Modules：中间件模块在使用 Identity 服务的 OpenStack 组件的地址空间中运行。这些模块拦截服务请求，提取用户凭据，并将它们发送到集中的服务器进行授权。中间件模块和 OpenStack 组件之间的集成使用 Python/Web服务器网关接口。 2.2、安装配置准备工作在安装和配置Identity服务之前，必须创建一个数据库。 12345678# 1、以root用户连接数据库服务器（密码：123456）mysql -p123456# 2、创建keystone数据库CREATE DATABASE keystone;# 3、将keystone数据库的所有权限都授予keystone用户（密码：KEYSTONE123）GRANT ALL PRIVILEGES ON keystone.* TO &#x27;keystone&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;KEYSTONE123&#x27;;# 4、退出数据库访问quit 2.3、安装配置默认配置文件因分布而异。您可能需要添加这些部分和选项，而不是修改现有的部分和选项。 1234567891011121314151617181920212223# 1、运行以下命令安装包yum install openstack-keystone httpd mod_wsgi -y# 2、编辑/etc/keystone/keystone.conf文件，完成如下操作:# 2.1、在[database]部分中，配置数据库访问（/\\[database]）yum -y install vim # 安装vimvim /etc/keystone/keystone.conf[database]connection = mysql+pymysql://keystone:KEYSTONE123@controller/keystone# 2.2、在[token]部分，配置Fernet令牌提供商[token]provider = fernet# 3、创建Identity服务数据库相关的数据表.创建完成后可以登录MySQL数据库，切换到keystone数据库，查看其中是否有表su -s /bin/sh -c &quot;keystone-manage db_sync&quot; keystonemysql -p123456use keystoneshow tables;quit# 4、初始化Fernet密钥库keystone-manage fernet_setup --keystone-user keystone --keystone-group keystonekeystone-manage credential_setup --keystone-user keystone --keystone-group keystone# 5、引导Identity服务keystone-manage bootstrap --bootstrap-password admin --bootstrap-admin-url http://controller:5000/v3/ --bootstrap-internal-url http://controller:5000/v3/ --bootstrap-public-url http://controller:5000/v3/ --bootstrap-region-id RegionOne 2.4、配置Apache HTTP服务器123456789# 1、编辑/etc/httpd/conf/httpd.conf文件并配置ServerName选项以引用控制节点vi /etc/httpd/conf/httpd.confServerName controller# 2、创建到/usr/share/keystone/wsgi-keystone.conf文件的链接ln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/# 3、启动Apache HTTP服务，并将其配置为在系统启动时自动启动systemctl enable httpd.service; systemctl start httpd.service# 4、检查服务systemctl status httpd 2.5、配置keystone的管理帐户123456789101112131415161718# 5、配置管理帐户.创建bash脚本，将配置写入，以便下次调用执行vim admin.sh#!/bin/bashexport OS_USERNAME=adminexport OS_PASSWORD=adminexport OS_PROJECT_NAME=adminexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_DOMAIN_NAME=Defaultexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3# 6、执行 admin.sh bash脚本source admin.sh# 7、查看Keystone服务列表,服务的地址(Openstack中称为Endpoint)openstack endpoint list# 8、使用openstack命令获取（id的值就是token）,openstack服务通过token来调用资源openstack token issue 2.6、创建域、项目、用户和角色Identity 服务为每个 OpenStack 服务提供身份验证服务。身份验证服务使用域、项目、用户和角色的组合。 12345678910111213# 1、虽然“default”域已经存在于本指南中的 keystone-manage 引导步骤中，但创建新域的正式方法是：openstack domain create --description &quot;An Example Domain&quot; example# 2、本指南使用一个服务项目，该项目包含添加到环境中的每个服务的唯一用户。创建服务项目openstack project create --domain default --description &quot;Service Project&quot; service# 3、常规(非管理)任务应该使用非特权项目和用户。例如，本指南创建 myproject 项目和 myuser# 3.1、创建 myproject 项目openstack project create --domain default --description &quot;Demo Project&quot; myproject# 3.2、创建 myuser（需要设置密码：myuser）openstack user create --domain default --password-prompt myuser# 3.3、创建myuser用户的角色openstack role create myrole# 3.4、将 myrole 角色分配给 myproject 项目和 myuser用户openstack role add --project myproject --user myuser myrole 2.7、验证操作在安装其他服务之前，验证Identity服务的操作。在控制器节点上执行这些命令。 123456# 1、取消临时的 OS/auth/url 和 OS/password/环境变量unset OS_AUTH_URL OS_PASSWORD# 2、以管理员用户请求一个身份验证令牌（此命令使用管理员用户的密码：admin）openstack --os-auth-url http://controller:5000/v3 --os-project-domain-name Default --os-user-domain-name Default --os-project-name admin --os-username admin token issue# 以在前一节中创建的 myuser用户，请求一个身份验证标记（此命令需要使用myuser用户密码：myuser）openstack --os-auth-url http://controller:5000/v3 --os-project-domain-name Default --os-user-domain-name Default --os-project-name myproject --os-username myuser token issue 2.8、创建 OpenStack 客户端环境脚本2.8.1、创建脚本前面的部分使用了环境变量和命令选项的组合，通过 openstack 客户机与 Identity 服务交互。为了提高客户端操作的效率，OpenStack 支持简单的客户端环境脚本，也称为 OpenRC 文件。这些脚本通常包含所有客户机的通用选项，但也支持唯一选项。 为管理和演示项目及用户创建客户端环境脚本。本指南的后续部分将引用这些脚本为客户端操作加载适当的凭据。 客户端环境脚本的路径是不受限制的。为了方便起见，您可以将脚本放在任何位置，但是要确保它们是可访问的，并且位于适合您部署的安全位置，因为它们确实包含敏感凭据。 12345678910111213141516171819202122232425# 1、创建并编辑 admin-openrc 文件，并添加以下内容:vim admin-openrc.sh#!/bin/bashexport OS_PROJECT_DOMAIN_NAME=Defaultexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_NAME=adminexport OS_USERNAME=adminexport OS_PASSWORD=adminexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2# 2、创建并编辑 myuser-openrc 文件，并添加以下内容：vim myuser-openrc.sh#!/bin/bashexport OS_PROJECT_DOMAIN_NAME=Defaultexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_NAME=myprojectexport OS_USERNAME=myuserexport OS_PASSWORD=myuserexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2 2.8.2、使用脚本要将客户机作为特定的项目和用户运行，只需在运行之前加载相关的客户机环境脚本即可。例如: 12345# 1、加载 admin-openrc 文件，用 Identity 服务的位置、 admin 项目和用户凭据填充环境变量source admin-openrc.sh# 2、请求认证令牌openstack token issue 三、镜像服务—Glance安装3.1、镜像服务概述Image服务(glance)允许用户发现、注册和检索虚拟机镜像。它提供了一个REST API，使您能够查询虚拟机镜像元数据并检索实际的镜像。您可以将通过Image服务提供的虚拟机镜像存储在各种位置，从简单的文件系统到像OpenStack Object Storage这样的对象存储系统。 为简单起见，本指南描述了如何配置Image服务以使用文件后端，文件后端上传并存储在托管Image服务的控制节点上的一个目录中。默认情况下，该目录为/var/lib/glance/images/。 在继续之前，请确保控制节点在这个目录中至少有几个G的可用空间。请记住，由于文件后端通常位于控制节点的本地，因此它通常不适合多节点glance部署。 OpenStack Image 服务是基础设施即服务(IaaS)的核心。它接受磁盘或服务器镜像的 API 请求，以及来自最终用户或 OpenStack Compute 组件的元数据定义。它还支持在各种存储库类型上存储磁盘或服务器镜像，包括 OpenStack 对象存储。 OpenStack镜像服务上运行大量的周期进程来支持缓存。同步服务通过集群确保一致性和可用性。其他周期性过程包括审计员、更新者和收割者。( Other periodic processes include auditors, updaters, and reapers.) OpenStack Image 服务包括以下组件: glance-api：调用镜像API来获取、检索和存储镜像。 glance-registry：存储、处理和检索关于镜像的元数据。元数据包括大小和类型等项。注册表是 OpenStack Image 服务使用的私有内部服务。不要向用户公开此服务。（Queens 版本中已经被弃用） Database：存储镜像元数据，您可以根据自己的喜好选择数据库。大多数部署使用MySQL或SQLite。 Metadata definition service：为供应商、管理员、服务和用户提供一个通用API，用于定义自己的自定义元数据。该元数据可以用于不同类型的资源，如镜像、工件（artifacts）、卷（volumes）和集料（aggregates）。定义包括新特性的键、描述、约束（key, description, constraints）以及可以与其关联的资源类型。 3.2、安装配置准备工作在安装和配置 Image 服务之前，必须创建数据库、服务凭据和 API 端点。 12345678910111213141516171819202122232425262728# 1、创建数据库，完成以下步骤:# 1.1、使用数据库访问客户端作为root用户连接到数据库服务器mysql -p123456# 1.2、创建创建glance数据库CREATE DATABASE glance;# 1.3、授予对glance数据库的适当访问权限（设置账号：glance；密码：GLANCE123）GRANT ALL PRIVILEGES ON glance.* TO &#x27;glance&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;GLANCE123&#x27;;# 1.4、退出数据库访问客户端quit# 2、获取管理员凭据以访问仅管理的CLI命令(可选)source admin-openrc.sh# 3、创建服务凭据，完成以下步骤:# 3.1、创建glance用户（设置密码：glance）openstack user create --domain default --password-prompt glance# 3.2、将admin角色赋给glance用户和service项目中openstack role add --project service --user glance admin# 3.3、创建glance服务实体openstack service create --name glance --description &quot;OpenStack Image&quot; image# 4、创建Image服务API端点（endpoints）openstack endpoint create --region RegionOne image public http://controller:9292openstack endpoint create --region RegionOne image internal http://controller:9292openstack endpoint create --region RegionOne image admin http://controller:9292# 5、查看服务API端点创建的结果openstack endpoint list 3.3、安装配置1234567891011121314151617181920212223242526272829303132333435363738# 1、安装glance服务模块相关软件包yum install openstack-glance -y# 2、编辑/etc/glance/glance-api.conf文件并完成以下操作:# 2.1、在[database]部分，配置数据库访问（这里的密码是glance数据库glance用户的密码：GLANCE123）vim /etc/glance/glance-api.conf[database]connection = mysql+pymysql://glance:GLANCE123@controller/glance# 2.2、在[keystone_authtoken]和[paste_deploy]部分中配置认证服务访问（注释掉或删除[keystone_authtoken]部分中的任何其他选项）这里的password是glance用户的密码[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = Defaultuser_domain_name = Defaultproject_name = serviceusername = glancepassword = glance[paste_deploy]flavor = keystone# 2.3、在[glance_store]部分，配置本地文件系统存储和image文件的位置[glance_store]stores = file,httpdefault_store = filefilesystem_store_datadir = /var/lib/glance/images/# 3、创建Image服务数据库su -s /bin/sh -c &quot;glance-manage db_sync&quot; glance# 补充说明：可以通过tail命令查看日志tail -f /var/log/glance/api.log# 4、启动Image服务，并配置它们在系统启动时自动启动systemctl enable openstack-glance-api.servicesystemctl start openstack-glance-api.service 3.4、验证操作使用 CirrOS 验证 Image 服务的操作，CirrOS 是一个小型的 Linux 映像，可以帮助您测试 OpenStack 部署。 1234567891011121314# 在控制器节点上执行这些命令# 1、获取管理员凭据以访问仅管理的CLI 命令（可选）source admin-openrc.sh# 2、下载源镜像（如果你的发行版中没有包含wget，那么就要安装wget。或者直接访问地址使用迅雷下载，下载完成后可以用xFTP将镜像上次到root目录下）wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img# 3、使用qcow2磁盘格式、bare容器格式和公共可见性将镜像上传到Image服务，以便所有项目都能访问它glance image-create --name &quot;cirros&quot; --file cirros-0.4.0-x86_64-disk.img --disk-format qcow2 --container-format bare --visibility public# 4、确认镜像上传和验证属性glance image-list# 或者openstack image list 四、placement服务—Placement安装4.1、Placement服务概览placement是从Nova 中分离出来的。placement API服务在14.0.0.0 Newton 版本中引入，并在19.0.0 Stein 版本中提取到新的placement存储库中。这是一个 REST API 堆栈和数据模型，用于跟踪资源提供者的清单和使用情况，以及不同类别的资源。例如，资源提供者可以是计算节点、共享存储池或 IP分配池。placement服务跟踪每个供应商的库存和使用情况。例如，在计算节点上创建的实例可能是来自计算节点资源提供程序的RAM和CPU等资源的消费者、来自外部共享存储池资源提供程序的磁盘以及来自外部IP池资源提供程序的IP地址。 消耗的资源类型被作为classes进行跟踪。。该服务提供了一组标准资源类(例如 DISK_GB, MEMORY_MB和 VCPU) ，并提供了根据需要定义自定义资源类的能力。 每个资源提供者也可能有一组描述资源提供者定性方面的特征。Traits 描述了资源提供者的一个方面，这个方面本身不能被使用，但是工作负载可能希望指定。例如，可用的磁盘可能是固态驱动器(SSD)。 4.2、部署步骤概述4.2.1、部署API服务Placement为使用Apache、nginx或其他支持WSGI的web服务器运行服务提供了Placement-apiwsgi脚本。根据用于部署OpenStack的打包解决方案的不同，WSGI脚本可能位于/usr/bin或/usr/local/bin中。 Placement-api作为标准的WSGI脚本，提供了大多数WSGI服务器期望找到的模块级应用程序属性。这意味着可以使用许多不同的服务器来运行它，从而在不同的部署场景中提供灵活性。常见的情况包括: apache2 with mod_wsgi apache2 with mod_proxy_uwsgi nginx with uwsgi nginx with gunicorn 在所有这些场景中，应用程序的主机、端口和挂载路径(或前缀)由web服务器的配置控制，而不是由放置应用程序的配置(placement.conf)控制。 当placement首次添加到DevStack时，它使用mod _ wsgi风格。后来它被更新为使用mod_proxy_uwsgi。研究这些变化对于理解相关的选择是有用的。 默认情况下，布局应用程序将从/etc/placement/placement.conf 获得其设置的配置，例如数据库连接URL。可以通过在启动应用程序的进程的环境中设置OS_placement_config_dir来更改配置文件所在的目录。对于最近发布的oslo.config，还可以在环境中设置配置选项。 本文档避免为placement服务声明一组安装说明。这是因为使用WSGI应用程序的一个主要要点是使部署尽可能灵活。因为placement API 服务本身是无状态的(所有状态都在数据库中) ，所以可以在负载均衡解决方案背后部署任意数量的服务器，以实现健壮和简单的伸缩。如果您熟悉通用WSGI应用程序的安装(使用上面的常见场景列表中的链接) ，这些技术将在这里适用。 4.2.2、同步数据库placement服务使用它自己的数据库，在配置的place_database部分中定义。placement_database.connection选项必须设置否则服务将不启动。命令行工具 placement-manage可用于将数据库表迁移到正确的形式，包括创建它们。连接选项所描述的数据库必须已经存在，并且已经定义了适当的访问控制。 同步的另一个选项是在配置中设置 placement_database.sync_on_startup 为True。这将在placement web 服务启动时执行任何缺少的数据库迁移。选择自动同步还是使用命令行工具取决于环境和部署工具的约束。 4.2.3、创建账户并更新服务目录在 Keystone 中创建一个具有管理员角色的placement服务用户。 placement API 是一个独立的服务，因此应该在服务目录中的placement服务类型下注册。placement的客户端(例如nova-compute节点中的资源跟踪器)将使用服务目录来查找placement端点。 4.3、安装配置准备工作在安装和配置置入服务之前，必须创建数据库、服务凭据和 API 端点。 1234567891011121314151617181920212223# 1、创建数据库# 1.1、使用数据库访问客户端作为根用户连接到数据库服务器mysql -p123456# 1.2、创建placement数据库CREATE DATABASE placement;# 1.3、授予对placement数据库的适当访问权限（设置账号：placement；密码：PLACEMENT123）GRANT ALL PRIVILEGES ON placement.* TO &#x27;placement&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;PLACEMENT123&#x27;;# 1.4、退出quit# 2、配置用户和端点Endpoints# 2.1、获取管理员凭据以访问仅管理的CLI命令source admin-openrc.sh# 2.2、创建placement用户（设置密码：placement）openstack user create --domain default --password-prompt placement# 2.3、使用管理员角色将Placement用户添加到服务项目中openstack role add --project service --user placement admin# 2.4、在服务目录中创建Placement API条目openstack service create --name placement --description &quot;Placement API&quot; placement# 2.5、创建Placement API服务端点（端点的 URL 将根据您的环境而变化(可能是8780而不是8778，或者根本没有端口)和主机名）openstack endpoint create --region RegionOne placement public http://controller:8778openstack endpoint create --region RegionOne placement internal http://controller:8778openstack endpoint create --region RegionOne placement admin http://controller:8778 4.4、安装配置123456789101112131415161718192021222324252627282930313233343536373839404142# 1、安装openstack-placement-api软件包yum install openstack-placement-api -y# 2、编辑/etc/placement/placement.conf文件并完成以下操作# 2.1、在[placement_database]部分，配置数据库访问vim /etc/placement/placement.conf[placement_database]connection = mysql+pymysql://placement:PLACEMENT123@controller/placement# 2.2、在[api]和[keystone_authtoken]部分配置Identity服务访问[api]auth_strategy = keystone[keystone_authtoken]auth_url = http://controller:5000/v3memcached_servers = controller:11211auth_type = passwordproject_domain_name = Defaultuser_domain_name = Defaultproject_name = serviceusername = placementpassword = placement# 2.3、由于打包错误，您必须通过将以下配置添加到/etc/httpd/conf.d/00-placement-api.conf来启用对 Placement API的访问（加到最后）vim /etc/httpd/conf.d/00-placement-api.conf&lt;Directory /usr/bin&gt; &lt;IfVersion &gt;= 2.4&gt; Require all granted &lt;/IfVersion&gt; &lt;IfVersion &lt; 2.4&gt; Order allow,deny Allow from all &lt;/IfVersion&gt;&lt;/Directory&gt;# 3、创建placement服务数据库su -s /bin/sh -c &quot;placement-manage db sync&quot; placement# 4、重新启动httpd服务systemctl restart httpd# 查看Apache服务版本号httpd -v 4.5、验证操作检查placement服务的运行情况 1234567891011121314# 1、获取管理员凭据以访问仅管理的CLI命令source admin-openrc.sh# 2、执行状态检查以确保一切正常placement-status upgrade check# 3、针对placement API运行一些命令# 3.1、安装osc-placement插件（没有安装pip的话，先安装epel软件源，再安装pip）yum -y install epel-releaseyum -y install python-pippip install osc-placement# 3.2、列出可用的资源类别和特性openstack --os-placement-api-version 1.2 resource class list --sort-column nameopenstack --os-placement-api-version 1.6 trait list --sort-column name 五、计算服务—nova安装5.1、计算服务概览使用 OpenStack Compute 托管和管理云计算系统。OpenStack Compute 是基础设施即服务(IaaS)系统的主要部分。主要的模块是用 Python 实现的。 OpenStack Compute与OpenStack Identity交互以进行身份验证，OpenStack Placement用于资源库存跟踪和选择，OpenStack Image 服务用于磁盘和服务器镜像，OpenStack Dashboard 用于用户和管理界面。镜像访问受到项目和用户的限制; 每个项目的配额都是有限的(例如，实例数)。OpenStack Compute可以在标准硬件上水平伸缩，并下载镜像以启动实例。 OpenStack Compute由以下部分及其组件组成: nova-api service：接受并响应最终用户的计算API调用。该服务支持OpenStack Compute API。它强制执行一些策略并启动大多数编排活动，例如运行实例。 nova-api-metadata service：接受实例的元数据请求。nova-api-metadata服务通常在多主机模式下运行nova-network安装时使用。 nova-compute service：通过hypervisor APIs创建和终止虚拟机实例的工作守护进程。例如: XenAPI for XenServer/XCP libvirt for KVM or QEMU VMwareAPI for VMware 处理过程相当复杂。基本上，守护进程接受来自队列的操作，并执行一系列系统命令，例如启动一个KVM实例并更新其在数据库中的状态。 nova-scheduler service：从队列中获取虚拟机实例请求，并确定它在哪个计算机服务器主机上运行。 nova-conductor module：协调nova-compute服务和数据库之间的交互。它消除了nova compute服务对云数据库的直接访问。nova-conductor模块水平缩放。但是，不要将其部署在nova compute服务运行的节点上。 nova-novncproxy daemon：提供一个代理，用于通过VNC连接访问正在运行的实例。支持基于浏览器的novnc客户端。 nova-spicehtml5proxy daemon：提供代理，用于通过SPICE连接访问正在运行的实例。支持基于浏览器的 html5客户端。 nova-xvpvncproxy daemon：提供代理，用于通过VNC连接访问正在运行的实例。支持openstack特定的Java客户端。nova-xvpvnxproxy 自19.0.0(Stein)以来就已弃用，并将在即将发布的版本中删除。 The queue：在守护进程之间传递消息的中央集线器。通常用RabbitMQ实现，但也有其他选项。 SQL database：存储大多数云基础设施构建时和运行时的状态，包括: Available instance types：可用的实例类型 Instances in use：使用中的实例 Available networks：可用网络 Projects：项目 理论上，OpenStack Compute可以支持SQLAlchemy支持的任何数据库。常见的数据库有sqlite3用于测试和开发工作、MySQL、MariaDB 和PostgreSQL。 以下操作需要注意具体是在哪个节点操作的！！！ 5.2、安装配置准备工作（控制节点）在安装和配置Compute服务之前，必须创建数据库、服务凭据和API端点。 1234567891011121314151617181920212223242526272829# 1、创建数据库，完成以下步骤:# 1.1、使用数据库访问客户端作为root用户连接到数据库服务器mysql -p123456# 1.2、创建nova api、nova和nova_cell0数据库CREATE DATABASE nova_api;CREATE DATABASE nova;CREATE DATABASE nova_cell0;# 1.3、授予nova用户对nova api、nova和nova_cell0数据库的适当访问权限（设置账号：nova；密码：NOVA123）GRANT ALL PRIVILEGES ON nova_api.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;NOVA123&#x27;;GRANT ALL PRIVILEGES ON nova.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;NOVA123&#x27;;GRANT ALL PRIVILEGES ON nova_cell0.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;NOVA123&#x27;;# 1.4、退出数据库访问客户端quit# 2、获取管理员凭据以访问仅管理的CLI命令source admin-openrc.sh# 3、创建Compute服务凭据# 3.1、创建nova用户（设置密码：nova）openstack user create --domain default --password-prompt nova# 3.2、将admin角色赋给nova用户和service项目中openstack role add --project service --user nova admin# 3.3、创建nova服务实体openstack service create --name nova --description &quot;OpenStack Compute&quot; compute# 4、创建Compute API服务端点openstack endpoint create --region RegionOne compute public http://controller:8774/v2.1openstack endpoint create --region RegionOne compute internal http://controller:8774/v2.1openstack endpoint create --region RegionOne compute admin http://controller:8774/v2.1 5.3、安装配置（控制节点）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 1、安装openstack-nova-api、openstack-nova-conductor、openstack-nova-novncproxy、openstack-nova-scheduler软件包yum install openstack-nova-api openstack-nova-conductor openstack-nova-novncproxy openstack-nova-scheduler -y# 2、编辑/etc/nova/nova.conf文件并完成以下操作# 2.1、在[DEFAULT]部分，只启用计算和元数据apivim /etc/nova/nova.conf[DEFAULT]enabled_apis = osapi_compute,metadata# 2.2、在[api_database]和[database]部分中，配置数据库访问[api_database]connection = mysql+pymysql://nova:NOVA123@controller/nova_api[database]connection = mysql+pymysql://nova:NOVA123@controller/nova# 2.3、在[DEFAULT]部分，配置RabbitMQ消息队列访问[DEFAULT]transport_url = rabbit://openstack:openstack123@controller:5672/# 2.4、在[api]和[keystone_authtoken]部分中，配置Identity服务访问[api]auth_strategy = keystone[keystone_authtoken]www_authenticate_uri = http://controller:5000/auth_url = http://controller:5000/memcached_servers = controller:11211auth_type = passwordproject_domain_name = Defaultuser_domain_name = Defaultproject_name = serviceusername = novapassword = nova# 2.5、在[DEFAULT]部分，配置 my_IP选项使用控制器节点的管理接口IP地址[DEFAULT]my_ip = 192.168.147.8# 2.6、在[DEFAULT]部分，启用对网络服务的支持（默认情况下，Compute 使用内部防火墙驱动程序。由于 Networking 服务包含防火墙驱动程序，因此必须使用 nova.virt.firewall 禁用 Compute 防火墙驱动程序。防火墙驱动程序）[DEFAULT]use_neutron = truefirewall_driver = nova.virt.firewall.NoopFirewallDriver# 2.7、在[VNC]部分，将VNC代理配置为使用控制器节点的管理接口IP地址[vnc]enabled = trueserver_listen = $my_ipserver_proxyclient_address = $my_ip# 2.8、在[glance]部分中，配置Image服务API的位置[glance]api_servers = http://controller:9292# 2.9、在[oslo_concurrency]部分，配置锁路径（python伪并发需要使用锁）[oslo_concurrency]lock_path = /var/lib/nova/tmp# 2.10、在[placement]部分，配置对placement服务的访问[placement]region_name = RegionOneproject_domain_name = Defaultproject_name = serviceauth_type = passworduser_domain_name = Defaultauth_url = http://controller:5000/v3username = placementpassword = placement# 3、创建nova-api数据库su -s /bin/sh -c &quot;nova-manage api_db sync&quot; nova# 4、注册cell0数据库su -s /bin/sh -c &quot;nova-manage cell_v2 map_cell0&quot; nova# 5、注册cell1 cell(单元格，cell是什么作用？？cell数据库则是用于保存创建失败且还没有确定位于哪个 cell 的虚机数据，比如当虚拟机调度失败时，该虚拟机数据就会被保存到cell数据库中。)su -s /bin/sh -c &quot;nova-manage cell_v2 create_cell --name=cell1 --verbose&quot; nova# 6、创建nova数据库su -s /bin/sh -c &quot;nova-manage db sync&quot; nova# 7、验证nova cell0和cell1是否正确注册su -s /bin/sh -c &quot;nova-manage cell_v2 list_cells&quot; nova# 8、启动Compute服务，并配置它们在系统启动时自启动systemctl enable openstack-nova-api.service openstack-nova-scheduler.service openstack-nova-conductor.service openstack-nova-novncproxy.servicesystemctl start openstack-nova-api.service openstack-nova-scheduler.service openstack-nova-conductor.service openstack-nova-novncproxy.service# 可以查看一下日志tail -f /var/log/nova/*.log cell作用参考：https://blog.csdn.net/Lihuihui006/article/details/112035435?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.essearch_pc_relevant 5.4、安装配置（计算节点）本节描述如何在计算节点上安装和配置Compute服务。该服务支持多个hypervisors来部署实例或虚拟机(vm)。为了简单起见，这个配置使用了Quick EMUlator (QEMU)hypervisor(管理程序)，并在计算节点上使用了基于内核的VM(KVM)扩展，这些计算节点支持虚拟机的虚拟硬件加速。在传统硬件上，这种配置使用通用QEMU hypervisor管理程序。您可以按照这些指令进行一些小的修改，以便使用附加的计算节点水平扩展环境。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 1、安装openstack-nova-compute软件包yum install openstack-nova-compute -y# 2、编辑/etc/nova/nova.conf文件并完成以下操作vim /etc/nova/nova.conf# 2.1、在[DEFAULT]部分，只启用计算和元数据api[DEFAULT]enabled_apis = osapi_compute,metadata# 2.2、在[DEFAULT]部分，配置RabbitMQ消息队列访问[DEFAULT]transport_url = rabbit://openstack:openstack123@controller#2.3、在[api]和[keystone_authtoken]部分中，配置Identity服务访问[api]auth_strategy = keystone[keystone_authtoken]www_authenticate_uri = http://controller:5000/auth_url = http://controller:5000/memcached_servers = controller:11211auth_type = passwordproject_domain_name = Defaultuser_domain_name = Defaultproject_name = serviceusername = novapassword = nova# 2.4、在[DEFAULT]部分，配置my_ip选项(compute节点的IP )[DEFAULT]my_ip = 192.168.147.9#2.5、在[DEFAULT]部分，启用对网络服务的支持（默认情况下，Compute使用内部防火墙服务。由于Networking包含防火墙服务，因此必须使用nova.virt.firewall禁用Compute防火墙服务。防火墙驱动程序）[DEFAULT]use_neutron = truefirewall_driver = nova.virt.firewall.NoopFirewallDriver# 2.6、在[vnc]部分，启用和配置远程控制台访问（服务器组件监听所有IP地址，而代理组件只监听计算节点的管理接口IP地址。基本URL表示可以使用web浏览器访问此计算节点上实例的远程控制台的位置。）[vnc]enabled = trueserver_listen = 0.0.0.0server_proxyclient_address = $my_ipnovncproxy_base_url = http://controller:6080/vnc_auto.html# 2.7、在[glance]部分中，配置Image服务API的位置[glance]api_servers = http://controller:9292# 2.8、在[oslo_concurrency]部分，配置锁路径[oslo_concurrency]lock_path = /var/lib/nova/tmp# 2.9、在[Placement]部分，配置Placement API[placement]region_name = RegionOneproject_domain_name = Defaultproject_name = serviceauth_type = passworduser_domain_name = Defaultauth_url = http://controller:5000/v3username = placementpassword = placement# 3、确定计算节点是否支持虚拟机的硬件加速/值（如果这个命令返回一个或更多的值，你的计算节点支持硬件加速/值，这通常不需要额外的配置。如果这个命令返回的值为零，那么您的计算节点不支持硬件加速，您必须将libvirt配置为使用QEMU而不是KVM。）egrep -c &#x27;(vmx|svm)&#x27; /proc/cpuinfo# （根据情况选择是否执行）编辑/etc/nova/nova.conf文件中的[libvirt]部分，如下所示vim /etc/nova/nova.conf[libvirt]virt_type = qemu# 4、启动Compute服务，包括它的依赖项，并配置它们在系统启动时自动启动systemctl enable libvirtd.service openstack-nova-compute.servicesystemctl start libvirtd.service openstack-nova-compute.service 5.5、将计算节点添加到cell数据库（控制节点）1234567891011121314# 1、获取管理员凭据以启用仅管理的 CLI 命令，然后确认数据库中有计算主机source admin-openrc.shopenstack compute service list --service nova-compute# 2、发现计算机主机su -s /bin/sh -c &quot;nova-manage cell_v2 discover_hosts --verbose&quot; nova# 3、配置主机自动发现，这样就不需要每次都手动执行发现主机命令了# 添加新的计算节点时，必须在控制器节点上运行nova-manage cell_v2 discover_hosts，以注册这些新的计算节点。或者，您可以在/etc/nova/nova.conf中设置适当的间隔自动发现主机vim /etc/nova/nova.conf[scheduler]discover_hosts_in_cells_interval = 300# 4、重启nova服务systemctl restart openstack-nova-api.service openstack-nova-scheduler.service openstack-nova-conductor.service openstack-nova-novncproxy.service 5.6、验证操作（控制节点）123456789101112131415# 验证计算机服务的操作# 1、获取管理员凭据以访问仅管理的 CLI 命令source admin-openrc.sh# 2、列出服务组件，以确认每个过程的成功启动和注册openstack compute service list# 3、列出Identity服务中的API端点，以验证与Identity服务的连接性openstack catalog list# 4、列出Image服务中的镜像，以验证与Image服务的连接性openstack image list# 5、检查cells和placement API是否正常工作，以及其他必要的先决条件是否到位nova-status upgrade check 六、网络服务—neutron安装此章节配置文件较为复杂，建议在配置前先对各节点(控制节点、计算节点)创建快照。 6.1、网络服务概述OpenStack Networking (neutron)允许您创建由其他OpenStack服务管理的接口设备并将其连接到网络。可以实现插件来适应不同的网络设备和软件，从而为OpenStack体系结构和部署提供灵活性。 它包括以下组成部分: neutron-server：接受API请求并将其路由到适当的OpenStack Networking插件以执行操作。 OpenStack Networking plug-ins and agents：插拔端口，创建网络或子网，并提供IP地址。这些插件和代理根据特定云中使用的供应商和技术而有所不同。OpenStack Networking 提供了用于Cisco虚拟交换机和物理交换机、NEC OpenFlow产品、Open vSwitch、Linux bridging和VMware NSX产品的插件和代理。 Messaging queue ：大多数OpenStack Networking安装使用它来在neutron-server和各种代理之间路由信息。它还充当数据库，用于存储特定插件的网络状态。 OpenStack Networking主要与OpenStack Compute交互，为其实例提供网络和连接。 6.2、网络(neturon)概念OpenStack Networking (neutron)管理OpenStack环境中虚拟网络基础设施(VNI)的所有网络方面和物理网络基础设施(PNI)的访问层方面。OpenStack Networking使项目能够创建高级虚拟网络拓扑，其中可能包括防火墙和虚拟专用网络(VPN)等服务。 Networking提供网络、子网和路由器作为对象抽象。每个抽象都具有模仿其物理对应物的功能: 网络包含子网，而路由器在不同的子网和网络之间路由流量。 任何给定的网络设置都至少有一个外部网络。与其他网络不同，外部网络不仅仅是一个虚拟定义的网络。相反，相反，它代表了在OpenStack安装之外可访问的物理外部网络的一部分的视图。外部网络上的任何人都可以访问外部网络上的IP地址。 除了外部网络，任何网络设置都有一个或多个内部网络。这些软件定义的网络直接连接到虚拟机。只有任何给定内部网络上的虚拟机，或者通过接口连接到类似路由器的子网上的虚拟机，才能直接访问连接到该网络的虚拟机。 对于外部网络访问虚拟机，反之亦然，网络之间的路由器是必需的。每个路由器都有一个连接到外部网络的网关和一个或多个连接到内部网络的接口。像物理路由器一样，子网可以访问连接到同一路由器的其他子网上的机器，机器可以通过路由器的网关访问外部网络。 此外，您可以将外部网络上的IP地址分配给内部网络上的端口。每当有东西连接到子网时，这个连接就被称为端口。您可以将外部网络IP地址与vm端口关联。这样，外部网络上的实体就可以访问虚拟机。 网络还支持安全组。安全组使管理员能够在组中定义防火墙规则。一个VM可以属于一个或多个安全组Networking应用这些安全组中的规则来阻止或取消阻止该VM的端口、端口范围或流量类型。 Networking使用的每个插件都有自己的概念。虽然对于操作虚拟网络基础设施(VNI)和OpenStack环境并不重要，但理解这些概念可以帮助您建立网络。所有网络安装都使用核心插件和安全组插件(或者只使用No-Op安全组插件)。此外，还可以使用防火墙即服务(FWaaS)。 在进行下面的操作之前要确保已经配置了主机网络(控制节点、计算节点、块存储节点Optional)。具体参考第一章节：配置虚拟机与基本服务配置 6.3、安装与配置准备工作（控制节点）在配置OpenStack Networking (neutron)服务之前，必须创建数据库、服务凭据和API端点。 12345678910111213141516171819202122232425# 1、要创建数据库，请完成以下步骤# 1.1、使用数据库访问客户端作为root用户连接到数据库服务器mysql -p123456# 1.2、neutronCREATE DATABASE neutron;# 1.3、授予neutron用户对neutron数据库的适当访问权限（设置账号：neutron；密码：NEUTRON123）GRANT ALL PRIVILEGES ON neutron.* TO &#x27;neutron&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;NEUTRON123&#x27;;# 1.4、退出quit# 2、如果 非管理员则需要获取管理员凭据以访问仅管理的 CLI 命令source admin-openrc.sh# 3、要创建服务凭据，请完成以下步骤:# 3.1、创建neutron用户（设置密码：neutron）openstack user create --domain default --password-prompt neutron# 3.2、将管理员角色赋给neutron用户openstack role add --project service --user neutron admin# 3.3、创建neutron服务实体openstack service create --name neutron --description &quot;OpenStack Networking&quot; network# 4、创建Networking服务API端点openstack endpoint create --region RegionOne network public http://controller:9696openstack endpoint create --region RegionOne network internal http://controller:9696openstack endpoint create --region RegionOne network admin http://controller:9696 配置网络选项：如前文“架构示例”中介绍，配置网络选项有2种（一种是提供商网络，一种是自助服务网络。可以使用备选方案1和备选方案2表示的两种体系结构之一部署Networking服务。) 备选方案1部署最简单的体系结构，只支持将实例附加到提供者(外部)网络。没有自助(专用)网络、路由器或浮动IP地址。只有管理员或其他特权用户可以管理提供商网络。 备选方案2增强了备选方案1，即支持将实例附加到自助服务网络的第三层服务。演示用户或其他无特权的用户可以管理自助服务网络，包括提供自助服务和提供者网络之间连接的路由器。此外，浮动IP地址从外部网络(如Internet)向使用自助服务网络的实例提供连接。 自助服务网络通常使用overlay networks。overlay网络协议，如VXLAN，包括额外的报头，增加了开销，减少了有效载荷或用户数据的可用空间。在不了解虚拟网络基础设施的情况下，实例试图使用1500字节的默认以太网最大传输单元(MTU)发送数据包。网络服务通过DHCP自动向实例提供正确的MTU值。但是，有些云镜像不使用DHCP或忽略DHCP MTU选项，需要使用元数据或脚本进行配置。自助服务网络还支持将实例附加到提供者网络。 在此选择备选方案1进行部署配置。 6.4、安装配置（控制节点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#### 注意网络选择1: 提供商网络。在控制器节点上进行如下安装和配置网络组件 ##### 1、安装组件yum install openstack-neutron openstack-neutron-ml2 openstack-neutron-linuxbridge ebtables -y# 2、配置服务器组件，网络服务器组件配置包括数据库、身份验证机制、消息队列、拓扑更改通知和插件。# 2.1、编辑/etc/neutron/neutron.conf 文件并完成以下操作:# 在[database]部分，配置数据库访问: vim /etc/neutron/neutron.conf[database]connection = mysql+pymysql://neutron:NEUTRON123@controller/neutron# 2.2、在[DEFAULT]部分，启用模块化层2(ML2)插件并禁用其他插件[DEFAULT]core_plugin = ml2service_plugins =# 2.3、在[DEFAULT]部分，配置RabbitMQ消息队列访问:[DEFAULT]transport_url = rabbit://openstack:openstack123@controller# 2.4、在[DEFAULT]和[keystone_authtoken]部分中，配置身份服务访问:[DEFAULT]auth_strategy = keystone[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = neutron# 2.5、在[DEFAULT]和[nova]部分中，配置网络以通知计算网络拓扑更改:[DEFAULT]notify_nova_on_port_status_changes = truenotify_nova_on_port_data_changes = true[nova]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = novapassword = nova# 2.6、在[oslo_concurrency]部分，配置锁路径:[oslo_concurrency]lock_path = /var/lib/neutron/tmp# 3、Configure the Modular Layer 2 (ML2) plug-in 配置模块化层2(ML2)插件# Ml2插件使用Linux 桥接机制为实例构建第2层(桥接和交换)虚拟网络基础设施（在配置ml2插件之后，删除type_drivers选项中的值可能会导致数据库不一致。）# 编辑/etc/neutron/plugins/ml2/ml2_conf.ini文件并完成以下操作:# 由于train版中ml2_conf.ini文件有缺失，可以访问以下地址将配置内容先复制然后覆盖train版中ml2_conf.ini文件，然后再修改。https://docs.openstack.org/ocata/config-reference/networking/samples/ml2_conf.ini.html# 3.1、在[ml2]部分，启用flat和VLAN网络:vim /etc/neutron/plugins/ml2/ml2_conf.ini[ml2]type_drivers = flat,vlan# 3.2、在[ml2]部分，禁用自助服务网络:[ml2]tenant_network_types =# 3.3、在[ml2]部分，启用Linux桥接机制:[ml2]mechanism_drivers = linuxbridge# 3.4、在[ml2]部分，启用端口安全扩展驱动程序:[ml2]extension_drivers = port_security# 3.5、在[ml2_type_flat]部分，将提供者虚拟网络配置为扁平flat网络（注意flat_networks的值）:[ml2_type_flat]# flat_networks = providerflat_networks = extnet# 3.6、在[securitygroup]部分，启用ipset以提高安全组规则的效率:[securitygroup]enable_ipset = true# 4、Configure the Linux bridge agent 配置Linux桥接代理# Linux桥代理为实例构建第2层(桥接和交换)虚拟网络基础设施，并处理安全组。# 4.1、编辑/etc/neutron/plugins/ml2/linuxbridge_agent.ini文件并完成以下操作:# 同样由于train版中linuxbridge_agent.ini文件有缺失，可以访问以下地址将配置内容先复制郭爱丽覆盖train版中linuxbridge_agent.ini文件，然后再修改。https://docs.openstack.org/ocata/config-reference/networking/samples/linuxbridge_agent.ini.html（d+G全部删除快捷键）# 在[linux_bridge]部分，将提供者虚拟网络映射到提供者物理网络接口:vim /etc/neutron/plugins/ml2/linuxbridge_agent.ini[linux_bridge]# physical_interface_mappings = provider:PROVIDER_INTERFACE_NAME（需要绑定的网卡）physical_interface_mappings = extnet:ens33# 4.2、在[VXLAN]部分，禁用VXLAN overlay网络:[vxlan]enable_vxlan = false# 4.3、在[securitygroup]部分，启用安全组并配置Linux桥iptables防火墙驱动程序:[securitygroup]enable_security_group = truefirewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver# 4.4、确保你的Linux操作系统内核支持网桥过滤器，验证所有以下sysctl值设置为1:(为了启用网桥支持，通常需要加载br_netfilter内核模块。)vim /etc/sysctl.confnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1# 4.5、加载br_netfilter内核模块modprobe br_netfilter# 加载完成后验证sysctl -p# 5、Configure the DHCP agent 配置DHCP代理# DHCP代理为虚拟网络提供DHCP服务# 5.1、编辑/etc/neutron/dhcp_agent.ini文件并完成以下操作:# 在[DEFAULT]部分，配置Linux桥接口驱动程序，Dnsmasq DHCP驱动程序，并启用隔离的元数据，以便提供商网络上的实例可以通过网络访问元数据:vim /etc/neutron/dhcp_agent.ini[DEFAULT]interface_driver = linuxbridgedhcp_driver = neutron.agent.linux.dhcp.Dnsmasqenable_isolated_metadata = true# 6、配置元数据代理# 元数据代理提供配置信息，例如对实例的凭据。# 6.1、编辑/etc/neutron/metadata_agent.ini文件并完成以下操作:# 在[DEFAULT]部分，配置元数据主机和共享密码:（设置元数据共享密码：METADATA123）vim /etc/neutron/metadata_agent.ini[DEFAULT]nova_metadata_host = controllermetadata_proxy_shared_secret = METADATA123# 7、将Compute服务配置为使用网络服务（必须安装Nova计算服务才能完成此步骤。）# 7.1、编辑/etc/nova/nova.conf文件并执行以下操作:# 在[neutron]部分，配置访问参数，启用元数据代理，并配置密码:（此处密码便是上面设置的元数据共享密码：METADATA123）vim /etc/nova/nova.conf[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = neutronservice_metadata_proxy = truemetadata_proxy_shared_secret = METADATA123# 8、完成安装# 8.1、Networking服务初始化脚本期望有一个指向ml2插件配置文件/etc/neutron/plugin.ini的符号链接/etc/neutron/plugins/ML2/ML2_conf.Ini.如果这个符号链接不存在，使用以下命令创建它:ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini# 8.2、创建neutron数据库（由于脚本需要完整的服务器配置文件和插件配置文件，因此网络的数据库填充稍后会发生。）su -s /bin/sh -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot; neutron# 8.3、重新启动Compute API服务:systemctl restart openstack-nova-api.service# 8.4、启动Networking服务并将其配置为在系统启动时自动启动systemctl enable neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.servicesystemctl start neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service 6.5、安装配置（计算节点）计算节点处理实例的连接性和安全组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 1、安装组件yum install openstack-neutron-linuxbridge ebtables ipset -y# 2、配置公共组件# 网络通用组件配置包括身份验证机制、消息队列和插件。# 2.1、编辑/etc/neutron/neutron.conf文件并完成以下操作:vim /etc/neutron/neutron.conf# 在[database]部分中，注释掉任何连接选项，因为计算节点不直接访问数据库。## 2.2、在[DEFAULT]部分，配置RabbitMQ消息队列访问:[DEFAULT]transport_url = rabbit://openstack:openstack123@controller# 2.3、在[ DEFAULT ]和[keystone_authtoken]部分中，配置身份服务访问:(注释掉或删除[keystone_authtoken]部分中的任何其他选项。)[DEFAULT]auth_strategy = keystone[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = neutron# 2.4、在[oslo_concurrency]部分，配置锁路径:[oslo_concurrency]lock_path = /var/lib/neutron/tmp# 3、配置网络选项（与控制节点一样选择‘备选方案1：提供商网络’进行网络的配置）# 配置Linux桥接代理# 3.1、编辑/etc/neutron/plugins/ml2/linuxbridge_agent.ini 文件并完成以下操作:# 在[linux_bridge]部分，将提供者虚拟网络映射到提供者物理网络接口:[linux_bridge]# physical_interface_mappings = provider:PROVIDER_INTERFACE_NAMEphysical_interface_mappings = extnet:ens33# 3.2、在[VXLAN]部分，禁用VXLAN覆盖网络:[vxlan]enable_vxlan = false# 3.3、在[securitygroup]部分，启用安全组并配置Linux桥iptables防火墙驱动程序：[securitygroup]enable_security_group = truefirewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver# 3.4、确保你的Linux操作系统内核支持网桥过滤器，验证所有以下sysctl值设置为1:vim /etc/sysctl.confnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1# 3.5、加载br_netfilter内核模块modprobe br_netfilter# 加载完成后验证sysctl -p# 4、将Compute服务配置为使用网络服务# 4.1、编辑/etc/nova/nova.conf 文件并完成以下操作:# 在[neutron]部分，配置访问参数:vim /etc/nova/nova.conf[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = neutron# 5、完成安装# 5.1、重新启动Compute服务:systemctl restart openstack-nova-compute.service# 5.2、启动 Linux 桥代理，并配置它在系统启动时自动启动:systemctl enable neutron-linuxbridge-agent.servicesystemctl start neutron-linuxbridge-agent.service 6.6、验证操作（控制节点）123456789# 在控制器节点上执行这些命令# 1、获取管理员凭据以访问仅管理的 CLI 命令:source admin-openrc.sh# 2、列出用于核实neutron-server程序成功启动的加载扩展程序:openstack extension list --network# 3、验证提供商网络配置。列出代理以验证neutron代理的成功启动：（输出应该指示控制器节点上的三个代理和每个计算节点上的一个代理。）openstack network agent list 七、启动实例（命令行方式）以上各模块都配置成功后，可以启动个实例。建议再次创建快照。 本节创建必要的虚拟网络以支持启动实例。网络选项1包括一个提供者(外部)网络和一个使用它的实例。网络选项2包括一个提供者网络和一个使用该网络的实例，以及一个使用该网络的自助服务(专用)网络。 7.1、创建提供者网络（控制节点）为配置Neutron时选择的网络选项创建虚拟网络。如果选择选项1，则只创建提供程序网络。如果选择了选项2，则创建提供者和自助服务网络。 在启动实例之前，必须创建必要的虚拟网络基础结构。对于网络选项1，实例使用通过第二层(桥接/交换)连接到物理网络基础设施的提供者(外部)网络。这个网络包括一个DHCP服务器，它为实例提供IP地址。 管理员或其他特权用户必须创建此网络，因为它直接连接到物理网络基础设施。下列说明和图表使用示例IP地址范围。必须根据特定环境调整它们。 1234567891011121314151617181920212223242526272829# 创建提供者网络# 1、在控制节点上，获取管理凭据以访问仅管理的 CLI 命令:source admin-openrc.sh# 2、创建网络# -- share 选项允许所有项目使用虚拟网络# --external选项将虚拟网络定义为外部的# 如果你想创建一个内部网络，你可以使用--internal。默认值是内部的# --provider-physical-network provider 和 --provider-network-type flat 选项使用来自以下文件的信息将平面虚拟网络连接到主机eth1接口上的平面（本机/未标记）物理网络：# ml2_conf.ini:（在上文已经配置的内容）# [ml2_type_flat]# flat_networks = extnet# linuxbridge_agent.ini:（在上文已经配置的内容）# [linux_bridge]# physical_interface_mappings = extnet:ens33# openstack network create --share --external --provider-physical-network provider --provider-network-type flat provideropenstack network create --share --external --provider-physical-network extnet --provider-network-type flat flat-extnet# 3、在网络上创建一个子网:# 用CIDR表示法将PROVIDER_network_CIDR替换为PROVIDER物理网络上的子网# 用要为实例分配的子网范围内的第一个和最后一个IP地址替换START_IP_ADDRESS和 END_IP_ADDRESS。此范围不能包括任何现有的活动IP地址。# 将DNS_RESOLVER替换为DNS解析器的IP地址。在大多数情况下，您可以使用 /etc/resolv.conf文件中的一个主机。# 将PROVIDER_NETWORK_GATEWAY替换为提供商网络上的网关IP地址，通常为“.1”IP地址。# 例子：# provider network使用203.0.113.0/24，网关是203.0.113.1。DHCP服务器为每个实例分配一个从203.0.113.101到203.0.113.250的IP地址。所有实例都使用8.8.4.4作为DNS解析器。# openstack subnet create --network provider --allocation-pool start=START_IP_ADDRESS,end=END_IP_ADDRESS --dns-nameserver DNS_RESOLVER --gateway PROVIDER_NETWORK_GATEWAY --subnet-range PROVIDER_NETWORK_CIDR provider# 根据自己情况填写，基于flat-extnet网络创建flat-subnet子网（在第一章的1.1节能够查看相关信息）openstack subnet create --network flat-extnet --allocation-pool start=192.168.147.128,end=192.168.147.254 --dns-nameserver 114.114.114.114 --gateway 192.168.147.2 --subnet-range 192.168.147.0/24 flat-subnet 7.2、Create m1.nano flavor123456789101112131415161718# 1、最小的默认flavor每个实例消耗512MB内存。对于计算节点内存小于4gb的环境，我们建议创建每个实例只需要64mb内存的m1.nano。仅在CirrOS镜像中使用这种flavor用于测试目的。openstack flavor create --id 0 --vcpus 1 --ram 64 --disk 1 m1.nano# 2、生成一个密钥对# 大多数云镜像支持公共密钥认证/密码认证，而不是传统的密码认证。在启动实例之前，必须向Compute服务添加一个公钥。（或者，您可以跳过ssh-keygen命令，使用现有的公钥。）ssh-keygen -q -N &quot;&quot;openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey# 3、验证配对钥匙的添加:openstack keypair list# 4、添加安全组规则# 默认情况下，默认安全组应用于所有实例，并包含拒绝远程访问实例的防火墙规则。对于CirrOS这样的Linux镜像，我们建议至少允许ICMP(ping)和安全shell(SSH)。# 向默认安全组添加规则:# 允许ICMP (ping):openstack security group rule create --proto icmp default# 允许安全 shell (SSH)访问:openstack security group rule create --proto tcp --dst-port 22 default 7.3、在provider network上启动一个实例如果选择网络选项1，则只能在提供者网络上启动实例。如果选择网络选项2，则可以在提供者网络和自助服务网络上启动实例。 要启动实例，您至少必须指定flavor, image name, network, security group, key, and instance name. 123456789101112131415161718192021222324252627282930313233343536# 解决访问地址虚拟控制台并未能起来的bug# 先查看服务器支持的虚拟化类型（如果没有安装libvirt，则需要安装yum -y install libvirt）virsh capabilities # 此命令在计算节点执行，查看&lt;machine maxCpus=&#x27;240&#x27;&gt;pc-i440fx-rhel7.2.0&lt;/machine&gt;# 配置/etc/nova/nova.confvim /etc/nova/nova.conf # 此配置在计算节点修改[libvirt]hw_machine_type = x86_64=pc-i440fx-rhel7.2.0 # 更改虚拟化类型cpu_mode = host-passthrough # 直接使用宿主机的cpu# 重启nova服务systemctl restart openstack-nova-* # 计算节点执行# 1、在控制器节点上，获取演示凭据以访问只有用户使用的 CLI 命令:source admin-openrc.sh# 2、flavor指定虚拟资源分配配置文件，其中包括处理器、内存和存储。# 列出可供选择的flavors:（可以通过ID引用flavor）openstack flavor list# 3、列出可用镜像Imagesopenstack image list# 4、列出可用网络networksopenstack network list# 5、列出可用的安全组security groups:openstack security group list# 6、以上条件都设置了，可以启动实例# 将PROVIDER_NET_ID替换为提供商提供商网络的ID。# 如果选择了选项1，并且您的环境只包含一个网络，则可以省略 -- nic 选项，因为 OpenStack 会自动选择唯一可用的网络。# openstack server create --flavor m1.nano --image cirros --nic net-id=PROVIDER_NET_ID --security-group default --key-name mykey provider-instanceopenstack server create --flavor m1.nano --image cirros --nic net-id=78e4aebb-a7dc-4c21-b922-f7e1d9999d51 --security-group default --key-name mykey vm1# 7、检查实例的状态（当生成过程成功完成时，状态从BUILD更改为ACTIVE。）openstack server list 7.4、使用虚拟控制台访问实例1234567891011# 无特殊说明则是在控制节点# 1、获取您的实例的虚拟网络计算(VNC:Virtual Network Computing)会话URL，并通过web浏览器访问它:# 如果您的web浏览器运行在一个无法解析控制器主机名的主机上，您可以用您的控制器节点上的管理接口的IP地址替换控制器。# CirrOS镜像包括常规的用户名/密码身份验证，并在登录提示符处提供这些凭据。登录到CirrOS 后，我们建议您使用ping验证网络连接性。openstack console url show vm1# 2、验证对提供者物理网络网关的访问:ping -c 4 192.168.147.2# 3、核实互联网的接入ping -c 4 www.baidu.com 7.5、远程访问实例12345# 1、验证从控制节点或提供者物理网络上的任何主机到实例的连接:ping -c 4 192.168.147.236# 2、从控制节点或提供者物理网络上的任何主机使用SSH访问您的实例:ssh cirros@192.168.147.236 八、Dashboard本节描述如何在控制器节点上安装和配置仪表板。 仪表板所需的唯一核心服务是Identity服务。您可以将仪表板与其他服务(如图像服务、计算和网络)结合使用。您还可以在具有独立服务(如对象存储)的环境中使用仪表板。 8.1、安装配置（控制节点）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 1、安装软件包yum install openstack-dashboard -y# 2、编辑/etc/openstack-dashboard/local_settings文件并完成以下操作:# 2.1、在控制器节点上配置仪表板以使用OpenStack服务vim /etc/openstack-dashboard/local_settingsOPENSTACK_HOST = &quot;controller&quot;# 2.2、允许主机访问仪表板（ [&#x27;*&#x27;] 接受所有主机）# ALLOWED_HOSTS = [&#x27;one.example.com&#x27;, &#x27;two.example.com&#x27;]ALLOWED_HOSTS = [&#x27;*&#x27;]# 2.3、配置memcached会话存储服务（注释掉任何其他会话存储配置。）SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cache&#x27;CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;, &#x27;LOCATION&#x27;: &#x27;controller:11211&#x27;, &#125;&#125;# 2.4、启用Identity API版本3OPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOST# 2.5、支持域名OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True# 2.6、配置API版本OPENSTACK_API_VERSIONS = &#123; &quot;identity&quot;: 3, &quot;image&quot;: 2, &quot;volume&quot;: 3,&#125;# 2.7、将Default配置为您通过仪表板创建的用户的默认域OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &quot;Default&quot;# 2.8、将user配置为您通过仪表板创建的用户的默认角色OPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot;# 2.9、如果您选择网络选项1，禁用对第三层网络服务的支持OPENSTACK_NEUTRON_NETWORK = &#123; &#x27;enable_router&#x27;: False, &#x27;enable_quotas&#x27;: False, &#x27;enable_distributed_router&#x27;: False, &#x27;enable_ha_router&#x27;: False, &#x27;enable_lb&#x27;: False, &#x27;enable_firewall&#x27;: False, &#x27;enable_vpn&#x27;: False, &#x27;enable_fip_topology_check&#x27;: False,&#125;# 2.10、可选地，配置时区TIME_ZONE = &quot;Asia/Shanghai&quot;# 2.11、在/etc/httpd/conf.d/openstack-dashboard.conf文件中添加如下内容（如果没有包含）vim /etc/httpd/conf.d/openstack-dashboard.confWSGIApplicationGroup %&#123;GLOBAL&#125;# 3、安装完成# 重新启动web服务器和会话存储服务systemctl restart httpd.service memcached.service# bug解决# 此时访问http://192.168.147.8/dashboard/，报Not Found：The requested URL /auth/login/ was not found on this server.# 编辑/etc/openstack-dashboard/local_settings，添加入下参数vim /etc/openstack-dashboard/local_settingsWEBROOT = &#x27;/dashboard&#x27;# 再次重启http，之后再访问http://192.168.147.8/dashboard/，域：default，用户名密码都是adminsystemctl restart httpd.service# 解决打不开虚拟机控制台问题。# 原因是打开虚拟机控制台的访问地址是controller，本地hosts没有解析，需要子啊hosts文件中添加解析# 解析内容为：192.168.147.8 controller# 或者在计算节点修改配置 vi /etc/nova/nova.conf，中的[vnc]部分的novncproxy_base_url参数值中的controller为192.168.147.8[vnc]novncproxy_base_url = http://192.168.147.8:6080/vnc_auto.html# 修改完成后重启systemctl restart openstack-nova-compute.service 官方文档：https://docs.openstack.org/install-guide/ https://docs.openstack.org/install-guide/openstack-services.html#minimal-deployment-for-train","categories":[],"tags":[]},{"title":"5.0.x用户界面定制","slug":"5-0-x用户界面定制","date":"2021-10-15T01:04:03.000Z","updated":"2021-10-15T06:29:15.628Z","comments":true,"path":"2021/10/15/5-0-x用户界面定制/","link":"","permalink":"https://giscloud.ltd/2021/10/15/5-0-x%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%AE%9A%E5%88%B6/","excerpt":"","text":"CAS 5.0.x 用户界面定制官方文档https://apereo.github.io/cas/5.0.x/installation/User-Interface-Customization.html# 概述为CAS用户界面(UI)添加标签只需要简单地编辑CSS样式表和一小部分相对简单的HTML包含文件(也称为视图)。您还可以选择修改显示的文本和/或在这些视图上添加额外的Javascript效果。 浏览器支持CAS用户界面应该适合所有主要的浏览器供应商: 谷歌Chrome Mozilla Firefox 苹果Safari 微软Internet Explorer 请注意，某些较老版本的IE，特别是ie9及以下版本，可能会给正确的UI配置带来额外的困难。 微软Internet Explorer为了指导CAS在兼容模式下呈现UI，在相关UI组件中添加以下内容: 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;/meta&gt; CSS和Javascript参考文档https://apereo.github.io/cas/5.0.x/installation/User-Interface-Customization-CSSJS.html CSS默认样式都包含在src/main/resources/static/css/cas.css中。这个位置在cas-theme-default.properties中设置。例如，如果你想创建自己的css/custom.css文件，你需要更新该文件中的standard.custom.css.file关键字。 12standard.custom.css.file=/css/cas.csscas.javascript.file=/js/cas.js 自适应设计CSS媒体查询为CAS带来响应式设计特性，允许采用者针对所有合适的设备和平台专注于一个主题。这些查询在同一个cas.css文件中定义。 Javascript如果你需要添加一些JavaScript，可以随意添加src/main/resources/static/js/cas.js。例如，你也可以创建自己的custom.js文件，并从bottom.html内部调用它，如下所示: 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/custom.js&quot;&gt;&lt;/script&gt; 如果你为每个服务开发主题，每个主题还可以在cas.javascript.file设置下指定一个定制的cas.js文件。 以下Javascript库被CAS自动使用: JQuery JQuery UI JQuery Cookie Bootstrap 异步加载脚本CAS将尝试异步加载上述脚本库，以避免阻塞页面呈现功能。脚本文件的加载由head.js库处理，由cas.js文件负责。 唯一同步加载的脚本是head.js库本身。 因为脚本(特别是JQuery)是异步加载的，所以任何放置在页面中、依赖于这些库的自定义Javascript可能不会在页面加载时立即起作用。CAS提供了一个回调函数，允许采用者在脚本加载完成时得到通知，这将是在实际页面中执行/加载其他依赖JQuery的javascript相关函数的安全时间。 123function jqueryReady() &#123; //Custom Javascript tasks can be carried out now via JQuery...&#125; 检查 CAPSLOCK在键入凭据密码期间，当CAPSLOCK键被打开时，CAS将显示一个简短的警告。这个检查由cas.js文件强制执行。 浏览器Cookie支持为了让CAS支持单点登录会话，浏览器必须支持并接受cookie。如果浏览器关闭了对cookie的支持，CAS将通知用户。这种行为是通过cas.js文件控制的。 Preserving Anchor Fragments(保存锚片段)Anchors/fragments可能会在重定向中丢失，因为表单post的服务器端处理程序会忽略客户端锚，除非附加到表单post url中。如果您希望cas身份验证的应用程序能够在书签时使用Anchors/fragments，那么就需要这样做。 cas.js的更改1234567891011121314151617181920/** * Prepares the login form for submission by appending any URI * fragment (hash) to the form action in order to propagate it * through the re-direct (i.e. store it client side). * @param form The login form object. * @returns true to allow the form to be submitted. */function prepareSubmit(form) &#123; // Extract the fragment from the browser&#x27;s current location. var hash = decodeURIComponent(self.document.location.hash); // The fragment value may not contain a leading # symbol if (hash &amp;&amp; hash.indexOf(&quot;#&quot;) === -1) &#123; hash = &quot;#&quot; + hash; &#125; // Append the fragment to the current action so that it persists to the redirected URL. form.action = form.action + hash; return true;&#125; 登入表格的更改12&lt;form method=&quot;post&quot; id=&quot;fm1&quot; th:object=&quot;$&#123;credential&#125;&quot;&gt; onsubmit=&quot;return prepareSubmit(this);&quot;&gt; Views视图文件都位于src/main/resources/templates中。 访问应用程序前的警告CAS能够在被重定向到服务之前警告用户。这允许用户在应用程序使用CAS登录时知道。(如果他们没有选择警告，他们可能在访问成功依赖于现有CAS单点登录会话的应用程序时看不到任何CAS屏幕。)一些CAS采用者删除了CAS登录视图中的“警告”复选框，并且不提供单点登录发生时的插页通知。 123456789...&lt;input id=&quot;warn&quot; name=&quot;warn&quot; value=&quot;true&quot; tabindex=&quot;3&quot; th:accesskey=&quot;#&#123;screen.welcome.label.warn.accesskey&#125;&quot; type=&quot;checkbox&quot; /&gt;&lt;label for=&quot;warn&quot; th:utext=&quot;#&#123;screen.welcome.label.warn&#125;&quot;/&gt;... “I am at a public workstation” authentication通过在登录页面上指示身份验证是在公共工作站上进行的，CAS能够允许用户选择退出SSO。通过选择这样做，CAS将不尊重后续的SSO会话，也不会生成设计用于这样做的TGC。 1234567...&lt;input id=&quot;publicWorkstation&quot; name=&quot;publicWorkstation&quot; value=&quot;false&quot; tabindex=&quot;4&quot; type=&quot;checkbox&quot; /&gt;&lt;label for=&quot;publicWorkstation&quot; th:utext=&quot;#&#123;screen.welcome.label.publicstation&#125;&quot;/&gt;... default service在没有向CAS提交服务的情况下，您可以指定一个默认服务url, CAS将重定向到该url。注意，这个默认服务与所有其他服务一样，必须经过CAS的授权和注册。 要查看CAS属性的相关列表，请参阅本指南https://apereo.github.io/cas/5.0.x/installation/Configuration-Properties.html。 LocalizationCAS Web应用程序包括许多本地化的消息文件: English (US) Spanish French Russian Dutch (Nederlands) Swedish (Svenskt) Italian (Italiano) Urdu Chinese (Simplified) German (Deutsch) Japanese Croatian Czech Slovenian Polish Portuguese (Brazil) Turkish Farsi Arabic 为了UI“调用”一种特定的语言，/login端点可以像这样传递一个locale参数: 1https://cas.server.edu/login?locale=it 注意，并不是所有的语言在CAS服务器版本中都是完整和准确的，因为翻译完全依赖于社区的贡献。要获得准确和完整的本地化消息列表，请始终参考英语语言包。 Configuration所有消息包都标记在messages_xx.properties属性文件中。位于src/main/resources。默认的语言包是针对英语的，因此被称为messages.properties。如果有任何自定义消息需要显示到视图中，它们也可以在custom_messages.properties属性文件中进行格式化。。 如果在激活的资源包中没有找到代码，则将逐字使用代码本身。 要查看CAS属性的相关列表，请参阅本指南https://apereo.github.io/cas/5.0.x/installation/Configuration-Properties.html。 ThemesDynamic themes随着Service Management应用程序的引入，部署人员现在能够根据不同的服务切换主题。例如，您可能希望教员应用程序和学生应用程序有不同的登录屏幕(不同样式)。或者，您想要显示白天时间和晚上时间的两个布局。本文档可以帮助您通过基本设置来实现这一点。 ThemesCAS被配置为基于service Registry中给定注册服务的主题属性来装饰视图。通过此方法激活的主题仍将保留CAS的默认视图，但将简单地对视图应用CSS和Javascript等装饰。视图的物理结构不能通过此方法修改。 Configuration 添加另一个主题属性文件，该文件必须放在src/main/resources文件夹的根目录下，命名为theme_name.properties。这个文件的内容应该匹配cas-theme-default属性文件。 在上面的文件中添加相关样式文件的位置，比如CSS和Javascript。 在theme属性下为服务定义指定主题的名称。 Themed ViewsCAS还可以利用服务的相关主题来选择性地选择将用于生成标准视图的UI视图集(casLoginView.html等)。这在以下情况下特别有用:针对不同类型读者的主题页面集在结构上完全不同，简单使用简单主题来扩充默认视图是不实际的。在这种情况下，可能需要新的视图页面。 默认情况下，与特定主题关联的视图应该在src/main/resources/templates/&lt;theme-id&gt;中找到 Configuration 根据主题id(即src/main/resources/templates/&lt;theme-id&gt;)将默认视图页面复制到一个新目录中。 在theme属性下为服务定义指定主题的名称。 实战","categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-cas","slug":"cas","permalink":"https://giscloud.ltd/tags/cas/"}]},{"title":"CAS","slug":"cas","date":"2021-10-13T06:42:14.000Z","updated":"2021-10-13T07:19:41.757Z","comments":true,"path":"2021/10/13/cas/","link":"","permalink":"https://giscloud.ltd/2021/10/13/cas/","excerpt":"","text":"搭建CAS服务器在多服务统一帐号的应用集中，单点登录是必不可少的。CAS就是成熟的单点登录框架之一。 1、构建CAS Server首先获取CAS源码，Github地址https://github.com/apereo/cas…。在此由于我本地是JDK8，所以我使用的是5.0.x版本 （1）下载或者克隆cas-overlay-template项目到本地，用Intellji Idea打开项目，然后添加当前项目为maven项目。执行Maven命令mvn install。执行结束后，该项目中会出现overlays目录，里面就是cas server的配置文件和class代码。 （2）mvn install执行后会在项目的target目录下生成一个cas.war包，将该war包放在apache tomcat的webapps/目录下并启动tomcat后，就能通过浏览器访问，访问地址localhost:port/cas。 （3）修改默认配置： 在项目中添加src/main/java和src/main/resources目录，并将src/main/java设置为代码文件根目录，将src/main/resources设置为资源文件根目录。例如要修改默认的登录用户名和密码（默认为casuser/Mellon），只需要将overlays目录下的WEB-INF/classes/目录中的application.properties文件复制到src/main/resources中，并修改最后一行配置cas.authn.accept.users=casuser::Mellon为cas.authn.accept.users=test::demo即可，让后重新执行mvn install并重新部署target/cas.war包即可验证。 overlays中的WEB-INF/classes/目录下的所有文件均可被覆盖，只需要将该目录下的文件复制到src/main/resources中，然后修改后重新打包部署，即可。 （4） CAS5.X默认的登录帐号是在application.properties中配置的（casuser::Mellon），正式环境下需要通过连接数据库进行校验，添加数据库验证的教程 https://fawnoos.com/2017/02/22/cas51-dbauthn-tutorial/ 2、客户端集成CAS集成CAS客户端实际上是为应用添加多个Filter。以SpringBoot的应用为例，可以采用自动注解的方式添加过滤器。这里我们使用了cas-client-autoconfig-support项目的集成能力，Github地址https://github.com/Unicon/cas-client-autoconfig-support （1）在Springboot应用的Maven配置文件（pom.xml）中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;net.unicon.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-client-autoconfig-support&lt;/artifactId&gt; &lt;version&gt;1.5.0-GA&lt;/version&gt;&lt;/dependency&gt; （2）在应用启动入口类上添加配置@EnableCasClient，示例： 123@SpringBootApplication@EnableCasClientpublic class MyApplication &#123; .. &#125; （3）在应用的配置文件中（application.properties/application.yml）添加如下配置： 1234# application.propertiescas.server-url-prefix=https://casserver.com/cas # 填CAS服务器的前缀cas.server-login-url=https://casserver.com/cas/login # 填CAS服务器的登录地址cas.client-host-url=https://casclient.com # 填客户端的访问前缀 12345# application.ymlcas: server-url-prefix: https://casserver.com/cas # 填CAS服务器的前缀 server-login-url: https://casserver.com/cas/login # 填CAS服务器的登录地址 client-host-url: https://casclient.com # 填客户端的访问前缀","categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]},{"title":"Springboot学习笔记","slug":"springboot学习笔记","date":"2021-10-11T09:10:07.000Z","updated":"2021-10-12T01:07:40.985Z","comments":true,"path":"2021/10/11/springboot学习笔记/","link":"","permalink":"https://giscloud.ltd/2021/10/11/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Springboot学习笔记一、实例1：使用Springboot输出“Hello World！”1、pom.xml1234567&lt;!--Web；springboot会自动配置web环境（配置Tomcat、WebMVC、Validator、JSON等）--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 2、Controller层1234567@RestController //代表这个类是REST风格的控制器，返回JSON/XML类型的数据public class HelloWorldController &#123; @RequestMapping(&quot;/Hello&quot;) //配置URL和方法之间的映射。可注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径 public String hello()&#123; return &quot;Hello.Spring boot!&quot;; &#125;&#125; 3、入口类12345678@SpringBootApplication //表示这个是spring boot项目的入口类public class HelloWorldApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldApplication.class, args); &#125;&#125; 二、项目打包成可执行的JAR包1234567# 使用Maven中的package将项目打包为JAR包# 如果报错：Failed to execute goal org.apache.maven.plugins:maven-resources-plugin:3.2.0；则需要修改maven-resources-plugin的版本&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/plugin&gt; 三、idea必会快捷键与设置快捷键设置的位置：“File→Settings→keymap→Main Menu→Code→Completion” 1、Ctrl+Space：实现快捷提示 2、Ctrl+Shift+Space：基于上下文环境智能匹配使用的方法 3、Ctrl+P：自动提示参数 4、实现自定义转义：Alt+Enter→Inject Ianguage→Inject language or reference(并按Enter)→JSON→Edit JSON Fragment→输入要转义的JSON值。如果要退出编辑JSON信息的视图，则按“Ctrl+F4”快捷键。 5、自定义高复用代码块（Live Template） 设置自定义代码操作方式：“File→Settings→Editor→Live Template→+”在弹出的窗口中就可以自定义代码块了。 abbreviation代表添加缩写语句，比如psvm Description代表描述信息，以便后期查询 Template text代表要复制的代码 sout：可以快速生成“System.out.println()” soutm:可以快速输出当前类和方法名：“System.out.println(hello.hello)” psfs:可以快速输出“public static final String” fori：可以快速输出“for(int i = 0; i &lt;; i++){}” ifn: 可以快速输出“if(args== null){}” 6、设置注释信息 “File→Settings→Editor→File and Code Template→includes→File Header” 12345678910/** *Copyright(C)，2021-$&#123;YEAR&#125;),国兴环保 *FileName:$&#123;NAME&#125; *Author: ZY *Date: $&#123;DATE&#125;$&#123;TIME&#125; *Description:$&#123;DESCRIPTION&#125; *history: *&lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; *作者姓名 修改时间 版本号 描述 */ 7、”Alt+Enter“快捷键 8、全局JDK、全局Maven、全局版本控制Git/Svn 9、自动导包与智能移除 10、自动生成语句 声明完参数后，参数后面接着输入“.notnull”并按“Enter”，idea就自动生成if语句。 在变量后面直接跟上for、sout、switch等表达式，idea会直接转换成相应的语句。 11、快速生成try/catch、if/else代码 ctrl+Alt+T快捷键 12、快速生成构造器，以及Getter/Setter、Override方法 在实体编辑窗口中，使用“Alt+Insert”快捷键 四、Springboot自动配置 自动配置通过注解@EnableAutoConfiguration来实现的，具有非入侵性。 在Idea中通过“Run→EditConfigurations→设置Program arguments参数为“–debug”。在启动应用程序之后即可在控制台中看到条件评估报告（即当前有哪些自动配置） 如果不需要某些自动配置，则可以通过注解@EnableAutoConfiguration的“exclude 或excludeName”属性来指定，或者在配置文件（application.properties或application.yml）中指定“spring.autoconfigure.exclude”的值。 五、Springboot热部署123456&lt;!-- 添加热部署依赖,该依赖在项目打包时会被禁用。如果项目中使用了Redis作为缓存，则禁止使用热部署，以免出现类型转换等问题。--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 六、实例2：定制启动画面1、自定义Banner 12345$&#123;AnsiColor.BRIGHT_RED&#125; //设置控制台中输出内容的颜色，具体参考org.springframework.boot.ansi.AnsiColorapplication.version:$&#123;application.version&#125; //用来获取MANIFEST.MF文件中的版本号 V2.4.4获取不到值spring−boot.formatted.version:$&#123;application.formatted-version&#125; //格式化后的&#123;application.version&#125;版本信息 V2.4.4获取不到值spring−boot.version:$&#123;spring-boot.version&#125; //Springboot的版本号spring-boot.formatted-version:$&#123;spring-boot.formatted-version&#125; //格式化后的&#123;spring-boot.version&#125;版本信息 七、Springboot常用注解1、系统注解 @Override : 用于修饰方法，表示此方法重写了父类方法 @Deprecated：用于修饰方法，表述此方法已过时。经常在版本升级后会遇到 @SuppressWarnnings：告诉编译器忽视某类编译警告 @SuppressWarnnings注解，它有一下几种属性 unchecked：未检查的转化 unused：未使用的变量 resource：泛型，即未指定类型 path：在类中的路径。原文件路径中有不存在的路径 deprecation：使用了某些不赞成使用的类和方法 fallthrough：switch语句执行到底，不会遇到break关键字 serial：实现Serialzable，但是未定义serialVersionUID rawtypes：没有传递带有泛型的参数 all：代表全部类型的警告 2、常用注解使用在类名上的注解 RestController：作用相当于@ResponseBody加@Controller Controller：声明此类是一个springMVC Controller对象 @service：声明一个业务处理类（实现非接口类） @Repository：声明一个数据库访问类（实现非接口类） @Component：代表其是Spring管理类，常用在无法用@service、@Repository描述的Spring管理的类上，相当于通用的注解。它用于把普通POJO（简单的java对象）实例化到Spring容器中。当类不属于注解@controller和@Service等时，就可以使用注解@Component来标注这个类 @Configuration：声明此类是一个配置类，常与@Bean配合使用。它作为Bean的载体，用来指示一个类声明、一个或多个@Bean方法，在运行时为这些Bean生成BeanDefinition和服务请求。 使用在类名上、属性或构造函数参数上的注解 @Resource：默认按byName自动注入。@Autowired与@Resource都可以用来装配@Bean，也都可以写在字段上或setter方法上。 @Autowired：默认按byName自动注入。它表示被修饰的类需要注入对象。Spring会扫描所有被@Autowired标注的类，然后根据类型在IoC容器中找到匹配的类进行注入。被@Autowired注解后的类不需要再导入文件。 使用在类名或方法上的注解 @RequestMapping：如果用在类上，则表示所有响应请求的方法的都是以该地址作为父路径的。该注解有6个属性。Params：指定Request中必须包含某些参数值，才让该方法处理。Headers：指定Request中必须包含某些指定的header值，才能让该方法处理请求。Value：指定请求的实际地址，指定的地址可以是URI Template模式。Method：指定请求的Method类型，如GET、POST、PUT、DELETE等。Consumes：指定处理请求的提交内容类型Content-Type，如“application/json,text/html”。Produces：指定返回的内容类型。只有当Request请求头中的Accept类型中包含该指定类型时才返回。 @Transactional：用于处理事务。它可以用在接口、接口方法、类及类方法上。但Spring不建议在接口或者接口方法上使用该注解。因为该注解只有在使用基于接口的代理时才会生效。如果异常被捕获（try{} catch{}）了，则事务就不会滚了。如果想让事务回滚，则必须再往外抛出异常（try{} catch{ throw Exception}）。 使用在类名或属性上的注解 @Qualifier：为Bean指定名称，随后再通过名字引用Bean。常于@Autowired一起使用。 12345678@Controllerpublic class HelloWorldBMvcController&#123; @RequestMapping(&quot;helloworldB&quot;) @ResponseBody public String helloWorld() throws Exception&#123; return &quot;Hello,Spring Boot!&quot;; &#125;&#125; 1/** * Description:标注为服务类 */public class ArticleServiceImpl implements ArticleService&#123; @Autowired private ArticleRepository articleRepository; /** * Description:重写service接口的实现，实现根据id查询对象功能 * @param id * @return */ @Override public Article findArticleById(long id)&#123; return articleRepository.findById(id); &#125;&#125; 1public class ArticleController&#123; @Resource private ArticleRepository articleRepository; /** * Description:新增保存方法 */ @PostMapping(&quot;&quot;) public String saveArticle(Article model)&#123; articleRepository.save(model); return &quot;redirect:/article/&quot;; &#125;&#125; 使用在方法上的注解使用在方法参数前 @RequestBody：常用来处理application/json、application/xml等Content-Type类型的数据，意味着HTTP消息是JSON/XML格式，需将其转化为指定类型参数 @PathVariable：将URL获取的参数映射到方法参数上 使用在方法上 @Bean：声明改方法的返回结果是一个由Spring容器管理的Bean。用于封装数据，一般有Setter、Getter方法。在MVC模型中，对应的是M（模型）。 @ResponseBody：通过适当的HttpMessageConverter将控制器中方法返回的对象转换为指定格式（JSON/XML）后，写入Response对象的Body数据区 举例：用AJAX（前端）提交数据，然后在控制器（后端）接收数据 1$.ajax(&#123; url:&quot;/post&quot;, type:&quot;POST&quot;, data:&#x27;&#123;&quot;name&quot;:&quot;geiao&quot;&#125;&#x27;, contentType:&quot;application/json charset=utf-8&quot; success:function(data)&#123; alert(&quot;request success!&quot;); &#125;&#125;) 1@requestMapping(&quot;/post&quot;)public void psot(@requestBody String name)&#123; //省略&#125; 3、其它注解使用在入口类/类名上的注解 @EnableAutoConfiguration：用来提供自动装配 @SpringBootApplication：用来启动入口类Application @EnableScheduling：用来开启计划任务。spring通过@Scheduled支持多种类型的计划任务，包括cron、fixDelay、fixRate等 @EnableAsync：用来开启异步注解功能 @ComponentScan：用来扫描组件，可自动发现和装配一些Bean。它根据定义的扫描路径，把符合扫描规则的类装配到Spring容器中，告诉Spring哪个包（package）的类会被spring自动扫描并且装入IoC容器。它对应XML配置中的元素。可以通过basePackages等熟悉来细粒度地定制自动扫描的范围，默认会从声明@ComponentScan所在类的包进行扫描。 @Aspec：标注切面，可以用来配置事务、日志、权限验证，在用户请求时做一些处理等。 使用在类上的注解 @ControllerAdvice：包含@Component，可以被扫描到。统一处理异常。 @ExceptionHandler：用在方法上，表示遇到这个异常就执行该方法。 @Value：用在属性上，用于获取配置文件中的值。 八、使用配置文件Springboot支持使用Properties和YANL两种配置方式，Properties的优先级要高于YAML。 1、使用YAML配置方式时需要注意一下几点： 原来以“.”分隔的key会变成树状结构。例如，“server.port=8080”会变成： 1server: port: 8080 在key后面的冒号后一定要跟一个空格 如果把原有的application.properties删除，则建议执行一下“maven -X clean install”命令YAML格式不支持用注解@PropertySource导入配置 可以在线对Properties和YAML文件内容进行互转 https://www.toyaml.com/index.html 实例3：演示如何使用application.yml文件1# 关闭自定义的Banner模式# spring.main.banner-mode = off# 定义服务器的配置# port定义要访问的端口# &quot;timeout: 30&quot;:定义Session的超时时间是30s# &quot;uri-encoding: UTF-8&quot;:定义URI编码是UTF-8格式server: port: 8090 servlet: session: timeout: 30 tmocat: uri-encoding: UTF-8age: 18name: zhaoyaopersoninfo: name: geiao age: 30 1@Component //声明此类是Spring管理类。它常用在无法用@Service、@Repository描述的Spring管理类上，相当于通用的注解@ConfigurationProperties(prefix=&quot;personinfo&quot;) // 把同类配置信息自动封装成一个实体类。其属性prefix代表配置文件中配置项的前缀，如在配置文件中定义的“personinfo”public class GetPersonInfoProperties &#123; private String name; private int age; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; 1@SpringBootTest // 用于测试的注解，可指定入口类或测试环境等@RunWith(SpringRunner.class) //在spring测试环境中进行测试public class propertTest &#123; @Value(&quot;$&#123;age&#125;&quot;) // 获取配置文件中的age private int age; @Value(&quot;$&#123;name&#125;&quot;) // 获取配置文件中的name private String name; @Test // 该注解表示一个测试方法 public void getAge()&#123; System.out.println(age); &#125; @Test // 该注解表示一个测试方法 public void getName()&#123; System.out.println(name); &#125; @Autowired private GetPersonInfoProperties getPersonInfoProperties; @Test public void getpersonproperties()&#123; System.out.println(&quot;name:&quot; + getPersonInfoProperties.getName() + &quot;;Age:&quot; + getPersonInfoProperties.getAge()); &#125;&#125; 实例4：演示如何使用application.priperties文件编写配置项 1com.example.nameYml=$&#123;nameYml:zhaoyao&#125;com.example.ageYml=30com.example.address[0]=杭州com.example.address[1]=南京com.example.address[2]=上海 编写类文件处理配置项 1@Data //自动生成Setter、Getter、toString、equals、hashCode方法，以及不带参数的构造方法@Component //代表其是Spring管理类，常用在无法用@service、@Repository描述的Spring管理的类上，相当于通用的注解。它用于把普通POJO（简单的java对象）实例化到Spring容器中。当类不属于注解@controller和@Service等时，就可以使用注解@Component来标注这个类@ConfigurationProperties(prefix = &quot;com.example&quot;)public class CoExample &#123; private String nameYml; private int ageYml; private List&lt;String&gt; address;&#125; 编写测试，获取配置项的值 1@SpringBootTest //用于测试的注解，可指定入口类或测试环境等@RunWith(SpringRunner.class) //在Spring测试环境中进行测试public class CoExampleTest &#123; @Autowired //自动注入 private CoExample coExample; @Test public void getNameYml()&#123; System.out.println(coExample.getNameYml()); &#125; @Test public void getAgeYml()&#123; System.out.println(coExample.getAgeYml()); &#125; @Test public void getAddress()&#123; System.out.println(coExample.getAddress()); &#125;&#125; 实例5：配置多环境不管是YML还是properties，都是在resources目录下新建3配置文件，分别表述测试环境（-dev）、生产环境（-prod）和主配置文件。通过主配置文件设置当前活动环境。 1spring.profiles.active=dev 可以在运行JAR包时指定配置文件。如果要在启动时指定使用pro配置文件，则可以输入以下 1java -jar name.jar --spring.profile.active=prod 九、常用的starterSpringboot学习笔记02一、使用Thymeleaf1、引入依赖 1&lt;!-- thyemleaf依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2、在模板中加入解析 xmlns:th=”http://www.thymeleaf.org&quot; 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;$&#123;article.title&#125;&quot;&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=&quot;$&#123;article.title&#125;&quot;&gt;标题&lt;/div&gt;&lt;div th:text=&quot;$&#123;article.body&#125;&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、配置视图解析器 Springboot某人的页面映射路径（即模板文件存放的位置）为“classpath:/templates/*.html”。静态文件路径为“classpath:/static/”,其中可以存放层叠样式表CSS、JS等模板共用的静态文件。 1# 配置Thyemleaf模板解析器属性# 代表thymeleaf模式.由于thymeleaf检查HTML格式很严格，禁止这种严格的语法检查模式spring.thymeleaf.mode=LEGACYHTML5# 代表thymeleaf模式spring.thymeleaf.encoding=UTF-8# 代表文档类型spring.thymeleaf.servlet.content-type=text/html# 为了便于测试，在开发时需要关闭缓存spring.thymeleaf.cache=false 二、thymeleaf基础语法usingthymeleaf.pdf 实例6：编写Thymeleaf视图以展示数据1//MVC模式的控制器@Controller //标注此控制器为MVC模式的控制器public class HelloWorldMvcController &#123; @RequestMapping(&quot;/helloWorld&quot;) //标注方法的URL映射路径“/helloWorld” public String helloWorld(Model model) throws Exception&#123; model.addAttribute(&quot;mav&quot;,&quot;Hello,Spring Boot!我是MVC结构！&quot;); //视图（view）的位置和名称。视图位于example文件夹下，视图文件为hello.html return &quot;example/hello&quot;; &#125;&#125; 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;$&#123;mav&#125;&quot;&gt;mav&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;container&quot;&gt;&lt;h1 th:text=&quot;$&#123;mav&#125;&quot;&gt;mav&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 三、使用控制器1、常用注解及URL映射（窄化映射）注解@RequestMapping可以在类和方法上使用。如果在类上使用，则可以窄化映射。 1@RestController@RequestMapping(&quot;news&quot;)public class NewsController()&#123; //GET方式 @RequestMapping(value=&quot;/&quot;,method=RequestMethod.GET) public void add()&#123;&#125; //POST方式 @RequestMapping(value=&quot;/&quot;,method=RequestMethod.POST) public void save()&#123;&#125;&#125;// GET方式访问add方法的路径：http://localhost:8090/news///POST方式访问save方法的路径：http://localhost:8090/news///@GetMapping(&quot;/&quot;)它等价于@RequestMapping(value=&quot;/&quot;,method=RequestMethod.GET)//GetMapping:处理GET请求。//@PostMapping:处理POST请求。//@DeleteMapping:处理删除请求。//PutMapping:处理修改请求。 2、处理HTTP请求的方法RequestMapping的method类型有GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE。可以通过这些method来处理前端用不同方法提交的数据。 GET：获取资源，如以下代码用GET方法根据id来获取文章对象。 1@GetMapping(&quot;/&#123;id&#125;&quot;)public ModelAndView getArticle(@PathVariable(&quot;id&quot;) Integer id) throws Exception&#123; Article articles = articleRepository.findNyId(id); ModelAndView mav = new ModelAndView(&quot;article/show&quot;); mav.addObject(&quot;article&quot;,articles); return mav;&#125; DELETE：在使用Restful风格则需要使用DELETE方法。在使用DELETE方法删除资源时，要注意判断是否成功，因为返回VOID类型。 一般有一下三种方法进行判断： 使用try catch exception：如果不发生异常，则默认为成功，但是这样并不好。 通过存储过程返回值来判断是否正确执行：如果执行成功，则返回1或在大于0 的值；如果执行失败，则返回0. 在执行DELETE方法前先查询是否有数据：在执行DELETE方法后返回值是0，所以，一般先查询一下是否有数据。 POST：如果需要添加对象，那一般使用POST方法传递一个Model对象。 PUT：如果对象需要更新，则用PUT方法发送请求。 PATCH：是一个新引入的方法，是对PUT方法的补充，用来对已知资源进行局部更新。 OPTIONS：该方法用于获取当前URL。若请求成功，则会在HTTP头中包含一个名为“Allow”的头，其值是所支持的方法，如值为“GET，POST”。它还允许客户端查看服务器的性能。如果遇到“500错误”，则OPTIONS不进行第二次请求。 TRACE：它显示服务器收到的请求，主要用于测试或诊断。 3、处理内容类型3.1、认识HTTP中的媒体类型Content-Type（1）常见的媒体格式如下： text/html：HTML格式 text/plain：纯文本格式 text/xml：XML格式 image/gif：GIF图片格式 image/jpeg：JPG图片格式 image/png：PNG图片格式 （2）以application开头的媒体格式如下： application/xhtml+xml：XHTML+XML格式 application/xml：XML数据格式 application/atom+xml：Atom XML聚合格式 application/json：JSON数据格式 application/pdf：PDF格式 application/msword：Word文档格式 application/octet-stream：二进制流数据（常用于文件下载） application/x-www-form-urlencoded：表单数据编码方式，只默认的ecType，form(表单)数据被默认编码为key/value格式发送给服务器。 multipart/from-data：如果在表单中进行文件上传，则需要使用该格式 3.2、使用Produces和Consumes处理内容类型（1）Produces的例子 1@RestController@RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.GET,produces=&quot;appliction/json&quot;) //返回json的话可以省略produces属性，因为RestController就是返回jsonpublic Mdoel getModel(@PathVariable String id, Model model)&#123; //&#125; 如果要强制返回编码，则加上编码类型 1produces = &quot;MediaType.APPLICATION_JSON_VALUE&quot;+&quot;;charset=utf-8&quot;) （2）Consumes的例子 在以下例子中，Consumes是消费者，用于指定获取消费者的数据类型。 1@RestController@RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.POST,produces=&quot;appliction/json&quot;) //返回json的话可以省略produces属性，因为RestController就是返回jsonpublic void addModel(@RequestBody Model model)&#123; //&#125; 3.3、在方法中使用参数1、获取路径中的值 1/** * Description: 根据id获取文章对象 * http://localhost/article/123 * 程序获取路径中123的值 */@GetMapping(&quot;article/&#123;id&#125;&quot;)public ModelAndView getArticle(@PathVariable(&quot;id&quot;) Integer id)&#123; Article articles = articleRepository.findById(id); ModelAndView mav = new ModelAndView(&quot;article/show&quot;); mav.addObject(&quot;article&quot;,articles); return mav;&#125; 2、获取路径中的参数 对于路径中的参数获取，可以写入方法的形参中。下面代码是获取参数username的值 1@RequestMapping(&quot;/addUser&quot;)public String addUser(String username)&#123; &#125;//这里的参数和上面所讲的获取路径值是不一样的，比如http://localhost/user/?username=zhaoyao，它是由“=”隔开的 3、通过Bean接收HTTP提交的对象 1public Stirng addUser(UserModel user) 4、用注解@ModelAttribute获取参数 用于从Model、Form或URL请求参数中获取属性值 1@RequestMapping(value=&quot;/addUser&quot;,method=RequestMethod.POST)public String addUser(@ModelAttribute(&quot;user&quot;) UserMdoel user) 5、通过HttpServletRequest接收参数 1@RequestMapping(&quot;/addUser&quot;)public String addUser(HttpServletRequest request)&#123; System.out.println(&quot;name:&quot;+request.GETParameter(&quot;username&quot;)); return &quot;/index&quot;;&#125; 6、用@RequestParam绑定入参 1//当请求参数不存在时会有异常发生，可以通过设置属性“required=false”来解决@RequestParam(value=&quot;username&quot;,required=false) 7、用@RequestBody接收JSON数据 1@RequestMapping(value=&quot;adduser&quot;,method=&#123;RequestMethod.POST&#125;)@ResponseBodypublic void saveUser(@RequestBody List&lt;User&gt; users)&#123; &#125; 8、上传文件MultipartFile 通过@RequestParam获取文件 1public String singleFileUpload(@RequestParam(&quot;file&quot;)MultipartFile file, RedireAttributes redireAttributes)&#123; if(file.isEmpty())&#123; redireAttributes.addFlashAttribute(&quot;message&quot;,&quot;请选择文件&quot;); return &quot;redirect:uploadStatus&quot;; &#125; try&#123; byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOAD_FOLDER+file.getOriginalFilename()); Files.write(path,bytes); redireAttributes.addFlashAttribute(&quot;message&quot;,&quot;成功上传 &quot; + file.getOriginalFilename() + &quot;&quot;); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; return &quot;redirect:/uploadStatus&quot;;&#125;//出于安全考虑，在生产环境中需要判断文件的类型，一般不允许上传“exe”等格式的可执行文件 9、上传图片 这里以常用的CKEditor4.10.1为例，实现上传图片功能。 1long l=System.currentTimeMillis();//新建日期对象Date date= new Date(l)；//转换日期输出格式SimpleDateFromat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);String nyr = dateFormat.format(date);private static String UPLOADED_FOLDER=&quot;/UPLOADED/img/&quot;;@PostMapping(&quot;/upload&quot;)@ResponseBody//注意，ckeditor上传的是upload字段public Map&lt;String,Object&gt; singleFileUpload(@RequestParam(&quot;upload&quot;) MultipartFile file, RedirectAttributes redirectAttributes)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); if(file.getOriginalFilename().endsWith(&quot;.jpg&quot;) || file.getOriginalFilename().endsWith(&quot;.png&quot;) || file.getOriginalFilename().endsWith(&quot;.gif&quot;) )&#123; try&#123; byte[] bytes = file.getBytes(); String S = nyr + Math.random() + file.getOriginalFilename(); Path path = Paths.get(UPLOADED_FOLDER + S); Files.write(path,bytes); map.put(&quot;uploaded&quot;,1); map.put(&quot;fileName&quot;,S); map.put(&quot;url&quot;,&quot;/UPLOAD/img/&quot;+S); map.put(&quot;message&quot;,&quot;上传成功&quot;); return map; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; else&#123; map.put(&quot;uploaded&quot;,0); map.put(&quot;fileName&quot;.file.getOriginalFilename()); map.put(&quot;url&quot;,&quot;/img/&quot;+file.getOriginalFilename()); map.put(&quot;message&quot;,&quot;图片后缀只支持png,jpg,gif,请检查！&quot;); return map; &#125; return map;&#125; 3.4、实例7:实现MVC模式的Web应用程序 添加依赖 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 创建实体模型 1@Datapublic class User &#123; //定义id private long id; //定义用户名 private String name; //定义年龄 private int age;&#125; 创建控制器 1@Controllerpublic class UserController &#123; //映射URL地址 @GetMapping(&quot;/user&quot;) public ModelAndView user()&#123; //实例化对象 User user= new User(); user.setName(&quot;zhaoyao&quot;); user.setAge(29); //定义MVC中的视图模板 ModelAndView modelAndView = new ModelAndView(&quot;user&quot;); //传递user实体对象给视图 modelAndView.addObject(&quot;user&quot;,user); return modelAndView; &#125;&#125; 创建用于展示的视图 1&lt;!DOCTYPE html&gt;&lt;!--thymeleaf模板支持--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;!--显示由控制器传递过来的实体user的值--&gt; &lt;!--/*@thymesVar id=&quot;user&quot; type=&quot;&quot;*/--&gt; &lt;div th:text=&quot;$&#123;user.name&#125;&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.5、实例8：验证表单数据并实现数据的自定义验证具体查看个人码云上项目名称thymeleaf springboot学习笔记03一、响应式编程1、响应式Web框架WebFlux。WebFlux可以在资源有限的情况下提高系统的吞吐量和伸缩性（不是提高性能）。这意味着，在资源相同的情况下，WebFlux可以处理更多的请求（不是业务）。 2、总结：MVC能满足的场景，就不需要改用WebFlux。WebFlux和MVC可以混合使用。如果开发I/O密集型服务，则可以选择用WebFlux实现。 3、如果在pom.xml文件中同时引用了spring-boot-starter-web和spring-boot-starter-webflux依赖，则优先使用spring-boot-starter-web。控制台输出的启动日志会提示“Tomcat started on port(s):….”，而使用WebFlux会提示“Netty started on port”。 4、Flux 和 Mono 是异步编程框架 Reactor 中的两种基本类型，而Spring Webflux 是基于 Reactor 构建的。Flux 表示空或多个结果，Mono 表示空或一个结果。两者可以进行转换，对一个Flux序列进行计数操作时，得到的结果是一个Mono对象。把多个Mono序列合并在一起，得到的是一个Flux对象。 5、开发WebFlux的流程 响应式开发流程 创建Handler类。这里的Handler类相当于Spring MVC的Controller层中的方法体。在响应式编程中，请求和响应不再是HttpServletRequest和HttpServletResponse，而是编程了ServerRequest和ServerResponse。 配置RouterFunction。RouterFunction和注解@RequestMapping相似，都用于提供URL路径。RouterFunction的格式也是固定的，第1个参数代表路径，第2个参数代表方法，合起来代表将URL映射到方法。 注解式开发流程 注解式开发方式只是Spring团队为了更好地迁移而提供的。和MVC开发模式一样，地址映射也是通过@RequestMapping提供的，用@Controller或@Restcontroller来代替Handler类。 由于个人对WebFlux的需求不大，此框架实例代码不做笔记，仙剑实例9、10、11见个人码云。 二、实例12：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询功能 1、下载安装MongoDB 4.4.4 以及oto 3T -1.42、创建用户名、密码及数据库表1--打开mongo.exe,切换到adminuse admin--创建用户名、密码和角色 db.createUser(&#123;user:&quot;geiao&quot;,pwd:&quot;1163117842@qqcom&quot;,roles:[&quot;root&quot;]&#125;) db.changeUserPassword(&#123;user:&quot;geiao&quot;,pwd:&quot;123456789&quot;,roles:[&quot;root&quot;]&#125;) 3、pom.xml添加依赖1&lt;!-- MongoDB--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;&lt;/dependency&gt; 4、配置文件中添加连接1# MongoDB spring.data.mongodb.uri=mongodb://用户名：密码@ip地址:端口号/数据库spring.data.mongodb.uri=mongodb://geiao:1163117842@qqcom@localhost:27017/test 5、entity→User.java1@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; //定义主键id private String id; //定义用户名 @NotBlank(message = &quot;用户名不能为空&quot;) @Length(min = 5,max = 20, message=&quot;用户名称长度为5-20个字符&quot;) private String name; //定义年龄 @NotNull(message = &quot;年龄不能为空&quot;) @Min(value = 18,message = &quot;最小18岁&quot;) @Max(value = 100,message = &quot;最大100岁&quot;) private Integer age; @Email(message = &quot;请输入邮箱&quot;) @NotBlank(message = &quot;邮箱不能为空&quot;) private String email; @MyConstraint private String answer;&#125; 6、repository→UserRepository.java1public interface UserRepository extends ReactiveMongoRepository&lt;User, String&gt; &#123;&#125; 7、controller→UserWebFluxController1@RestController@RequestMapping(path = &quot;/userWebFlux&quot;)public class UserWebFluxController &#123; @Autowired private UserRepository userRepository; @GetMapping(&quot;/listMongoDB&quot;) public Flux&lt;User&gt; getAll()&#123; return userRepository.findAll(); &#125; //启动测试就可以发现查询是一个一个出来的，而不是一下返回。 @GetMapping(value = &quot;/listdelay&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Flux&lt;User&gt; getAlldelay()&#123; return userRepository.findAll().delayElements(Duration.ofSeconds(1)); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(@PathVariable String id) &#123; return userRepository.findById(id) .map(getUser -&gt; ResponseEntity.ok(getUser)) .defaultIfEmpty(ResponseEntity.notFound().build()); &#125; @PostMapping(&quot;&quot;) public Mono&lt;User&gt; createUser(@Valid User user)&#123; return userRepository.save(user); &#125; @PutMapping(&quot;/&#123;id&#125;&quot;) public Mono updateUser(@PathVariable(value = &quot;id&quot;) String id, @Valid User user)&#123; return userRepository.findById(id) .flatMap(existingUser -&gt;&#123; existingUser.setName(user.getName()); return userRepository.save(existingUser); &#125;) .map(updateUser -&gt; new ResponseEntity&lt;&gt;(updateUser, HttpStatus.OK)) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(@PathVariable(value = &quot;id&quot;) String id)&#123; return userRepository.findById(id) .flatMap(existingUser -&gt; userRepository.delete(existingUser) .then(Mono.just(new ResponseEntity&lt;Void&gt;(HttpStatus.OK))) ) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125;&#125; 8、测试接口 根据id查询 1http://localhost:8090/userWebFlux/6066c330945856c2309af2b6 新增测试 1localhost:8090/userWebFlux?id=1&amp;name=geiao1&amp;age=21&amp;email=1111111@qq.com&amp;answer=北京 根据Id更新数据 1localhost:8090/userWebFlux/6066c330945856c2309af2b6?id=&quot;2&quot;&amp;name=zhangsan&amp;age=38&amp;email=1163117842@qq.com&amp;answer=上海","categories":[{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]},{"title":"Test","slug":"test","date":"2021-10-11T07:00:19.000Z","updated":"2021-10-11T09:04:41.715Z","comments":true,"path":"2021/10/11/test/","link":"","permalink":"https://giscloud.ltd/2021/10/11/test/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"},{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-cas","slug":"cas","permalink":"https://giscloud.ltd/tags/cas/"},{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"},{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]}