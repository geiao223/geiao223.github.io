{"meta":{"title":"耀的个人站","subtitle":"","description":"个人博客站点","author":"zhaoyao","url":"https://giscloud.ltd","root":"/"},"pages":[{"title":"分类","date":"2021-12-30T13:22:38.600Z","updated":"2021-10-09T06:21:59.118Z","comments":false,"path":"categories/index.html","permalink":"https://giscloud.ltd/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-30T13:22:38.597Z","updated":"2021-10-10T08:47:29.387Z","comments":false,"path":"about/index.html","permalink":"https://giscloud.ltd/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2021-12-30T13:22:38.601Z","updated":"2021-10-09T06:21:59.120Z","comments":false,"path":"tags/index.html","permalink":"https://giscloud.ltd/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"5.0.x用户界面定制","slug":"5-0-x用户界面定制","date":"2021-10-15T01:04:03.000Z","updated":"2021-10-15T06:29:15.628Z","comments":true,"path":"2021/10/15/5-0-x用户界面定制/","link":"","permalink":"https://giscloud.ltd/2021/10/15/5-0-x%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%AE%9A%E5%88%B6/","excerpt":"","text":"CAS 5.0.x 用户界面定制官方文档https://apereo.github.io/cas/5.0.x/installation/User-Interface-Customization.html# 概述为CAS用户界面(UI)添加标签只需要简单地编辑CSS样式表和一小部分相对简单的HTML包含文件(也称为视图)。您还可以选择修改显示的文本和/或在这些视图上添加额外的Javascript效果。 浏览器支持CAS用户界面应该适合所有主要的浏览器供应商: 谷歌Chrome Mozilla Firefox 苹果Safari 微软Internet Explorer 请注意，某些较老版本的IE，特别是ie9及以下版本，可能会给正确的UI配置带来额外的困难。 微软Internet Explorer为了指导CAS在兼容模式下呈现UI，在相关UI组件中添加以下内容: 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;/meta&gt; CSS和Javascript参考文档https://apereo.github.io/cas/5.0.x/installation/User-Interface-Customization-CSSJS.html CSS默认样式都包含在src/main/resources/static/css/cas.css中。这个位置在cas-theme-default.properties中设置。例如，如果你想创建自己的css/custom.css文件，你需要更新该文件中的standard.custom.css.file关键字。 12standard.custom.css.file=/css/cas.csscas.javascript.file=/js/cas.js 自适应设计CSS媒体查询为CAS带来响应式设计特性，允许采用者针对所有合适的设备和平台专注于一个主题。这些查询在同一个cas.css文件中定义。 Javascript如果你需要添加一些JavaScript，可以随意添加src/main/resources/static/js/cas.js。例如，你也可以创建自己的custom.js文件，并从bottom.html内部调用它，如下所示: 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/custom.js&quot;&gt;&lt;/script&gt; 如果你为每个服务开发主题，每个主题还可以在cas.javascript.file设置下指定一个定制的cas.js文件。 以下Javascript库被CAS自动使用: JQuery JQuery UI JQuery Cookie Bootstrap 异步加载脚本CAS将尝试异步加载上述脚本库，以避免阻塞页面呈现功能。脚本文件的加载由head.js库处理，由cas.js文件负责。 唯一同步加载的脚本是head.js库本身。 因为脚本(特别是JQuery)是异步加载的，所以任何放置在页面中、依赖于这些库的自定义Javascript可能不会在页面加载时立即起作用。CAS提供了一个回调函数，允许采用者在脚本加载完成时得到通知，这将是在实际页面中执行/加载其他依赖JQuery的javascript相关函数的安全时间。 123function jqueryReady() &#123; //Custom Javascript tasks can be carried out now via JQuery...&#125; 检查 CAPSLOCK在键入凭据密码期间，当CAPSLOCK键被打开时，CAS将显示一个简短的警告。这个检查由cas.js文件强制执行。 浏览器Cookie支持为了让CAS支持单点登录会话，浏览器必须支持并接受cookie。如果浏览器关闭了对cookie的支持，CAS将通知用户。这种行为是通过cas.js文件控制的。 Preserving Anchor Fragments(保存锚片段)Anchors/fragments可能会在重定向中丢失，因为表单post的服务器端处理程序会忽略客户端锚，除非附加到表单post url中。如果您希望cas身份验证的应用程序能够在书签时使用Anchors/fragments，那么就需要这样做。 cas.js的更改1234567891011121314151617181920/** * Prepares the login form for submission by appending any URI * fragment (hash) to the form action in order to propagate it * through the re-direct (i.e. store it client side). * @param form The login form object. * @returns true to allow the form to be submitted. */function prepareSubmit(form) &#123; // Extract the fragment from the browser&#x27;s current location. var hash = decodeURIComponent(self.document.location.hash); // The fragment value may not contain a leading # symbol if (hash &amp;&amp; hash.indexOf(&quot;#&quot;) === -1) &#123; hash = &quot;#&quot; + hash; &#125; // Append the fragment to the current action so that it persists to the redirected URL. form.action = form.action + hash; return true;&#125; 登入表格的更改12&lt;form method=&quot;post&quot; id=&quot;fm1&quot; th:object=&quot;$&#123;credential&#125;&quot;&gt; onsubmit=&quot;return prepareSubmit(this);&quot;&gt; Views视图文件都位于src/main/resources/templates中。 访问应用程序前的警告CAS能够在被重定向到服务之前警告用户。这允许用户在应用程序使用CAS登录时知道。(如果他们没有选择警告，他们可能在访问成功依赖于现有CAS单点登录会话的应用程序时看不到任何CAS屏幕。)一些CAS采用者删除了CAS登录视图中的“警告”复选框，并且不提供单点登录发生时的插页通知。 123456789...&lt;input id=&quot;warn&quot; name=&quot;warn&quot; value=&quot;true&quot; tabindex=&quot;3&quot; th:accesskey=&quot;#&#123;screen.welcome.label.warn.accesskey&#125;&quot; type=&quot;checkbox&quot; /&gt;&lt;label for=&quot;warn&quot; th:utext=&quot;#&#123;screen.welcome.label.warn&#125;&quot;/&gt;... “I am at a public workstation” authentication通过在登录页面上指示身份验证是在公共工作站上进行的，CAS能够允许用户选择退出SSO。通过选择这样做，CAS将不尊重后续的SSO会话，也不会生成设计用于这样做的TGC。 1234567...&lt;input id=&quot;publicWorkstation&quot; name=&quot;publicWorkstation&quot; value=&quot;false&quot; tabindex=&quot;4&quot; type=&quot;checkbox&quot; /&gt;&lt;label for=&quot;publicWorkstation&quot; th:utext=&quot;#&#123;screen.welcome.label.publicstation&#125;&quot;/&gt;... default service在没有向CAS提交服务的情况下，您可以指定一个默认服务url, CAS将重定向到该url。注意，这个默认服务与所有其他服务一样，必须经过CAS的授权和注册。 要查看CAS属性的相关列表，请参阅本指南https://apereo.github.io/cas/5.0.x/installation/Configuration-Properties.html。 LocalizationCAS Web应用程序包括许多本地化的消息文件: English (US) Spanish French Russian Dutch (Nederlands) Swedish (Svenskt) Italian (Italiano) Urdu Chinese (Simplified) German (Deutsch) Japanese Croatian Czech Slovenian Polish Portuguese (Brazil) Turkish Farsi Arabic 为了UI“调用”一种特定的语言，/login端点可以像这样传递一个locale参数: 1https://cas.server.edu/login?locale=it 注意，并不是所有的语言在CAS服务器版本中都是完整和准确的，因为翻译完全依赖于社区的贡献。要获得准确和完整的本地化消息列表，请始终参考英语语言包。 Configuration所有消息包都标记在messages_xx.properties属性文件中。位于src/main/resources。默认的语言包是针对英语的，因此被称为messages.properties。如果有任何自定义消息需要显示到视图中，它们也可以在custom_messages.properties属性文件中进行格式化。。 如果在激活的资源包中没有找到代码，则将逐字使用代码本身。 要查看CAS属性的相关列表，请参阅本指南https://apereo.github.io/cas/5.0.x/installation/Configuration-Properties.html。 ThemesDynamic themes随着Service Management应用程序的引入，部署人员现在能够根据不同的服务切换主题。例如，您可能希望教员应用程序和学生应用程序有不同的登录屏幕(不同样式)。或者，您想要显示白天时间和晚上时间的两个布局。本文档可以帮助您通过基本设置来实现这一点。 ThemesCAS被配置为基于service Registry中给定注册服务的主题属性来装饰视图。通过此方法激活的主题仍将保留CAS的默认视图，但将简单地对视图应用CSS和Javascript等装饰。视图的物理结构不能通过此方法修改。 Configuration 添加另一个主题属性文件，该文件必须放在src/main/resources文件夹的根目录下，命名为theme_name.properties。这个文件的内容应该匹配cas-theme-default属性文件。 在上面的文件中添加相关样式文件的位置，比如CSS和Javascript。 在theme属性下为服务定义指定主题的名称。 Themed ViewsCAS还可以利用服务的相关主题来选择性地选择将用于生成标准视图的UI视图集(casLoginView.html等)。这在以下情况下特别有用:针对不同类型读者的主题页面集在结构上完全不同，简单使用简单主题来扩充默认视图是不实际的。在这种情况下，可能需要新的视图页面。 默认情况下，与特定主题关联的视图应该在src/main/resources/templates/&lt;theme-id&gt;中找到 Configuration 根据主题id(即src/main/resources/templates/&lt;theme-id&gt;)将默认视图页面复制到一个新目录中。 在theme属性下为服务定义指定主题的名称。 实战","categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-cas","slug":"cas","permalink":"https://giscloud.ltd/tags/cas/"}]},{"title":"CAS","slug":"cas","date":"2021-10-13T06:42:14.000Z","updated":"2021-10-13T07:19:41.757Z","comments":true,"path":"2021/10/13/cas/","link":"","permalink":"https://giscloud.ltd/2021/10/13/cas/","excerpt":"","text":"搭建CAS服务器在多服务统一帐号的应用集中，单点登录是必不可少的。CAS就是成熟的单点登录框架之一。 1、构建CAS Server首先获取CAS源码，Github地址https://github.com/apereo/cas…。在此由于我本地是JDK8，所以我使用的是5.0.x版本 （1）下载或者克隆cas-overlay-template项目到本地，用Intellji Idea打开项目，然后添加当前项目为maven项目。执行Maven命令mvn install。执行结束后，该项目中会出现overlays目录，里面就是cas server的配置文件和class代码。 （2）mvn install执行后会在项目的target目录下生成一个cas.war包，将该war包放在apache tomcat的webapps/目录下并启动tomcat后，就能通过浏览器访问，访问地址localhost:port/cas。 （3）修改默认配置： 在项目中添加src/main/java和src/main/resources目录，并将src/main/java设置为代码文件根目录，将src/main/resources设置为资源文件根目录。例如要修改默认的登录用户名和密码（默认为casuser/Mellon），只需要将overlays目录下的WEB-INF/classes/目录中的application.properties文件复制到src/main/resources中，并修改最后一行配置cas.authn.accept.users=casuser::Mellon为cas.authn.accept.users=test::demo即可，让后重新执行mvn install并重新部署target/cas.war包即可验证。 overlays中的WEB-INF/classes/目录下的所有文件均可被覆盖，只需要将该目录下的文件复制到src/main/resources中，然后修改后重新打包部署，即可。 （4） CAS5.X默认的登录帐号是在application.properties中配置的（casuser::Mellon），正式环境下需要通过连接数据库进行校验，添加数据库验证的教程 https://fawnoos.com/2017/02/22/cas51-dbauthn-tutorial/ 2、客户端集成CAS集成CAS客户端实际上是为应用添加多个Filter。以SpringBoot的应用为例，可以采用自动注解的方式添加过滤器。这里我们使用了cas-client-autoconfig-support项目的集成能力，Github地址https://github.com/Unicon/cas-client-autoconfig-support （1）在Springboot应用的Maven配置文件（pom.xml）中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;net.unicon.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-client-autoconfig-support&lt;/artifactId&gt; &lt;version&gt;1.5.0-GA&lt;/version&gt;&lt;/dependency&gt; （2）在应用启动入口类上添加配置@EnableCasClient，示例： 123@SpringBootApplication@EnableCasClientpublic class MyApplication &#123; .. &#125; （3）在应用的配置文件中（application.properties/application.yml）添加如下配置： 1234# application.propertiescas.server-url-prefix=https://casserver.com/cas # 填CAS服务器的前缀cas.server-login-url=https://casserver.com/cas/login # 填CAS服务器的登录地址cas.client-host-url=https://casclient.com # 填客户端的访问前缀 12345# application.ymlcas: server-url-prefix: https://casserver.com/cas # 填CAS服务器的前缀 server-login-url: https://casserver.com/cas/login # 填CAS服务器的登录地址 client-host-url: https://casclient.com # 填客户端的访问前缀","categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]},{"title":"Springboot学习笔记","slug":"springboot学习笔记","date":"2021-10-11T09:10:07.000Z","updated":"2021-10-12T01:07:40.985Z","comments":true,"path":"2021/10/11/springboot学习笔记/","link":"","permalink":"https://giscloud.ltd/2021/10/11/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Springboot学习笔记一、实例1：使用Springboot输出“Hello World！”1、pom.xml1234567&lt;!--Web；springboot会自动配置web环境（配置Tomcat、WebMVC、Validator、JSON等）--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 2、Controller层1234567@RestController //代表这个类是REST风格的控制器，返回JSON/XML类型的数据public class HelloWorldController &#123; @RequestMapping(&quot;/Hello&quot;) //配置URL和方法之间的映射。可注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径 public String hello()&#123; return &quot;Hello.Spring boot!&quot;; &#125;&#125; 3、入口类12345678@SpringBootApplication //表示这个是spring boot项目的入口类public class HelloWorldApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldApplication.class, args); &#125;&#125; 二、项目打包成可执行的JAR包1234567# 使用Maven中的package将项目打包为JAR包# 如果报错：Failed to execute goal org.apache.maven.plugins:maven-resources-plugin:3.2.0；则需要修改maven-resources-plugin的版本&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/plugin&gt; 三、idea必会快捷键与设置快捷键设置的位置：“File→Settings→keymap→Main Menu→Code→Completion” 1、Ctrl+Space：实现快捷提示 2、Ctrl+Shift+Space：基于上下文环境智能匹配使用的方法 3、Ctrl+P：自动提示参数 4、实现自定义转义：Alt+Enter→Inject Ianguage→Inject language or reference(并按Enter)→JSON→Edit JSON Fragment→输入要转义的JSON值。如果要退出编辑JSON信息的视图，则按“Ctrl+F4”快捷键。 5、自定义高复用代码块（Live Template） 设置自定义代码操作方式：“File→Settings→Editor→Live Template→+”在弹出的窗口中就可以自定义代码块了。 abbreviation代表添加缩写语句，比如psvm Description代表描述信息，以便后期查询 Template text代表要复制的代码 sout：可以快速生成“System.out.println()” soutm:可以快速输出当前类和方法名：“System.out.println(hello.hello)” psfs:可以快速输出“public static final String” fori：可以快速输出“for(int i = 0; i &lt;; i++){}” ifn: 可以快速输出“if(args== null){}” 6、设置注释信息 “File→Settings→Editor→File and Code Template→includes→File Header” 12345678910/** *Copyright(C)，2021-$&#123;YEAR&#125;),国兴环保 *FileName:$&#123;NAME&#125; *Author: ZY *Date: $&#123;DATE&#125;$&#123;TIME&#125; *Description:$&#123;DESCRIPTION&#125; *history: *&lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; *作者姓名 修改时间 版本号 描述 */ 7、”Alt+Enter“快捷键 8、全局JDK、全局Maven、全局版本控制Git/Svn 9、自动导包与智能移除 10、自动生成语句 声明完参数后，参数后面接着输入“.notnull”并按“Enter”，idea就自动生成if语句。 在变量后面直接跟上for、sout、switch等表达式，idea会直接转换成相应的语句。 11、快速生成try/catch、if/else代码 ctrl+Alt+T快捷键 12、快速生成构造器，以及Getter/Setter、Override方法 在实体编辑窗口中，使用“Alt+Insert”快捷键 四、Springboot自动配置 自动配置通过注解@EnableAutoConfiguration来实现的，具有非入侵性。 在Idea中通过“Run→EditConfigurations→设置Program arguments参数为“–debug”。在启动应用程序之后即可在控制台中看到条件评估报告（即当前有哪些自动配置） 如果不需要某些自动配置，则可以通过注解@EnableAutoConfiguration的“exclude 或excludeName”属性来指定，或者在配置文件（application.properties或application.yml）中指定“spring.autoconfigure.exclude”的值。 五、Springboot热部署123456&lt;!-- 添加热部署依赖,该依赖在项目打包时会被禁用。如果项目中使用了Redis作为缓存，则禁止使用热部署，以免出现类型转换等问题。--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 六、实例2：定制启动画面1、自定义Banner 12345$&#123;AnsiColor.BRIGHT_RED&#125; //设置控制台中输出内容的颜色，具体参考org.springframework.boot.ansi.AnsiColorapplication.version:$&#123;application.version&#125; //用来获取MANIFEST.MF文件中的版本号 V2.4.4获取不到值spring−boot.formatted.version:$&#123;application.formatted-version&#125; //格式化后的&#123;application.version&#125;版本信息 V2.4.4获取不到值spring−boot.version:$&#123;spring-boot.version&#125; //Springboot的版本号spring-boot.formatted-version:$&#123;spring-boot.formatted-version&#125; //格式化后的&#123;spring-boot.version&#125;版本信息 七、Springboot常用注解1、系统注解 @Override : 用于修饰方法，表示此方法重写了父类方法 @Deprecated：用于修饰方法，表述此方法已过时。经常在版本升级后会遇到 @SuppressWarnnings：告诉编译器忽视某类编译警告 @SuppressWarnnings注解，它有一下几种属性 unchecked：未检查的转化 unused：未使用的变量 resource：泛型，即未指定类型 path：在类中的路径。原文件路径中有不存在的路径 deprecation：使用了某些不赞成使用的类和方法 fallthrough：switch语句执行到底，不会遇到break关键字 serial：实现Serialzable，但是未定义serialVersionUID rawtypes：没有传递带有泛型的参数 all：代表全部类型的警告 2、常用注解使用在类名上的注解 RestController：作用相当于@ResponseBody加@Controller Controller：声明此类是一个springMVC Controller对象 @service：声明一个业务处理类（实现非接口类） @Repository：声明一个数据库访问类（实现非接口类） @Component：代表其是Spring管理类，常用在无法用@service、@Repository描述的Spring管理的类上，相当于通用的注解。它用于把普通POJO（简单的java对象）实例化到Spring容器中。当类不属于注解@controller和@Service等时，就可以使用注解@Component来标注这个类 @Configuration：声明此类是一个配置类，常与@Bean配合使用。它作为Bean的载体，用来指示一个类声明、一个或多个@Bean方法，在运行时为这些Bean生成BeanDefinition和服务请求。 使用在类名上、属性或构造函数参数上的注解 @Resource：默认按byName自动注入。@Autowired与@Resource都可以用来装配@Bean，也都可以写在字段上或setter方法上。 @Autowired：默认按byName自动注入。它表示被修饰的类需要注入对象。Spring会扫描所有被@Autowired标注的类，然后根据类型在IoC容器中找到匹配的类进行注入。被@Autowired注解后的类不需要再导入文件。 使用在类名或方法上的注解 @RequestMapping：如果用在类上，则表示所有响应请求的方法的都是以该地址作为父路径的。该注解有6个属性。Params：指定Request中必须包含某些参数值，才让该方法处理。Headers：指定Request中必须包含某些指定的header值，才能让该方法处理请求。Value：指定请求的实际地址，指定的地址可以是URI Template模式。Method：指定请求的Method类型，如GET、POST、PUT、DELETE等。Consumes：指定处理请求的提交内容类型Content-Type，如“application/json,text/html”。Produces：指定返回的内容类型。只有当Request请求头中的Accept类型中包含该指定类型时才返回。 @Transactional：用于处理事务。它可以用在接口、接口方法、类及类方法上。但Spring不建议在接口或者接口方法上使用该注解。因为该注解只有在使用基于接口的代理时才会生效。如果异常被捕获（try{} catch{}）了，则事务就不会滚了。如果想让事务回滚，则必须再往外抛出异常（try{} catch{ throw Exception}）。 使用在类名或属性上的注解 @Qualifier：为Bean指定名称，随后再通过名字引用Bean。常于@Autowired一起使用。 12345678@Controllerpublic class HelloWorldBMvcController&#123; @RequestMapping(&quot;helloworldB&quot;) @ResponseBody public String helloWorld() throws Exception&#123; return &quot;Hello,Spring Boot!&quot;; &#125;&#125; 1/** * Description:标注为服务类 */public class ArticleServiceImpl implements ArticleService&#123; @Autowired private ArticleRepository articleRepository; /** * Description:重写service接口的实现，实现根据id查询对象功能 * @param id * @return */ @Override public Article findArticleById(long id)&#123; return articleRepository.findById(id); &#125;&#125; 1public class ArticleController&#123; @Resource private ArticleRepository articleRepository; /** * Description:新增保存方法 */ @PostMapping(&quot;&quot;) public String saveArticle(Article model)&#123; articleRepository.save(model); return &quot;redirect:/article/&quot;; &#125;&#125; 使用在方法上的注解使用在方法参数前 @RequestBody：常用来处理application/json、application/xml等Content-Type类型的数据，意味着HTTP消息是JSON/XML格式，需将其转化为指定类型参数 @PathVariable：将URL获取的参数映射到方法参数上 使用在方法上 @Bean：声明改方法的返回结果是一个由Spring容器管理的Bean。用于封装数据，一般有Setter、Getter方法。在MVC模型中，对应的是M（模型）。 @ResponseBody：通过适当的HttpMessageConverter将控制器中方法返回的对象转换为指定格式（JSON/XML）后，写入Response对象的Body数据区 举例：用AJAX（前端）提交数据，然后在控制器（后端）接收数据 1$.ajax(&#123; url:&quot;/post&quot;, type:&quot;POST&quot;, data:&#x27;&#123;&quot;name&quot;:&quot;geiao&quot;&#125;&#x27;, contentType:&quot;application/json charset=utf-8&quot; success:function(data)&#123; alert(&quot;request success!&quot;); &#125;&#125;) 1@requestMapping(&quot;/post&quot;)public void psot(@requestBody String name)&#123; //省略&#125; 3、其它注解使用在入口类/类名上的注解 @EnableAutoConfiguration：用来提供自动装配 @SpringBootApplication：用来启动入口类Application @EnableScheduling：用来开启计划任务。spring通过@Scheduled支持多种类型的计划任务，包括cron、fixDelay、fixRate等 @EnableAsync：用来开启异步注解功能 @ComponentScan：用来扫描组件，可自动发现和装配一些Bean。它根据定义的扫描路径，把符合扫描规则的类装配到Spring容器中，告诉Spring哪个包（package）的类会被spring自动扫描并且装入IoC容器。它对应XML配置中的元素。可以通过basePackages等熟悉来细粒度地定制自动扫描的范围，默认会从声明@ComponentScan所在类的包进行扫描。 @Aspec：标注切面，可以用来配置事务、日志、权限验证，在用户请求时做一些处理等。 使用在类上的注解 @ControllerAdvice：包含@Component，可以被扫描到。统一处理异常。 @ExceptionHandler：用在方法上，表示遇到这个异常就执行该方法。 @Value：用在属性上，用于获取配置文件中的值。 八、使用配置文件Springboot支持使用Properties和YANL两种配置方式，Properties的优先级要高于YAML。 1、使用YAML配置方式时需要注意一下几点： 原来以“.”分隔的key会变成树状结构。例如，“server.port=8080”会变成： 1server: port: 8080 在key后面的冒号后一定要跟一个空格 如果把原有的application.properties删除，则建议执行一下“maven -X clean install”命令YAML格式不支持用注解@PropertySource导入配置 可以在线对Properties和YAML文件内容进行互转 https://www.toyaml.com/index.html 实例3：演示如何使用application.yml文件1# 关闭自定义的Banner模式# spring.main.banner-mode = off# 定义服务器的配置# port定义要访问的端口# &quot;timeout: 30&quot;:定义Session的超时时间是30s# &quot;uri-encoding: UTF-8&quot;:定义URI编码是UTF-8格式server: port: 8090 servlet: session: timeout: 30 tmocat: uri-encoding: UTF-8age: 18name: zhaoyaopersoninfo: name: geiao age: 30 1@Component //声明此类是Spring管理类。它常用在无法用@Service、@Repository描述的Spring管理类上，相当于通用的注解@ConfigurationProperties(prefix=&quot;personinfo&quot;) // 把同类配置信息自动封装成一个实体类。其属性prefix代表配置文件中配置项的前缀，如在配置文件中定义的“personinfo”public class GetPersonInfoProperties &#123; private String name; private int age; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; 1@SpringBootTest // 用于测试的注解，可指定入口类或测试环境等@RunWith(SpringRunner.class) //在spring测试环境中进行测试public class propertTest &#123; @Value(&quot;$&#123;age&#125;&quot;) // 获取配置文件中的age private int age; @Value(&quot;$&#123;name&#125;&quot;) // 获取配置文件中的name private String name; @Test // 该注解表示一个测试方法 public void getAge()&#123; System.out.println(age); &#125; @Test // 该注解表示一个测试方法 public void getName()&#123; System.out.println(name); &#125; @Autowired private GetPersonInfoProperties getPersonInfoProperties; @Test public void getpersonproperties()&#123; System.out.println(&quot;name:&quot; + getPersonInfoProperties.getName() + &quot;;Age:&quot; + getPersonInfoProperties.getAge()); &#125;&#125; 实例4：演示如何使用application.priperties文件编写配置项 1com.example.nameYml=$&#123;nameYml:zhaoyao&#125;com.example.ageYml=30com.example.address[0]=杭州com.example.address[1]=南京com.example.address[2]=上海 编写类文件处理配置项 1@Data //自动生成Setter、Getter、toString、equals、hashCode方法，以及不带参数的构造方法@Component //代表其是Spring管理类，常用在无法用@service、@Repository描述的Spring管理的类上，相当于通用的注解。它用于把普通POJO（简单的java对象）实例化到Spring容器中。当类不属于注解@controller和@Service等时，就可以使用注解@Component来标注这个类@ConfigurationProperties(prefix = &quot;com.example&quot;)public class CoExample &#123; private String nameYml; private int ageYml; private List&lt;String&gt; address;&#125; 编写测试，获取配置项的值 1@SpringBootTest //用于测试的注解，可指定入口类或测试环境等@RunWith(SpringRunner.class) //在Spring测试环境中进行测试public class CoExampleTest &#123; @Autowired //自动注入 private CoExample coExample; @Test public void getNameYml()&#123; System.out.println(coExample.getNameYml()); &#125; @Test public void getAgeYml()&#123; System.out.println(coExample.getAgeYml()); &#125; @Test public void getAddress()&#123; System.out.println(coExample.getAddress()); &#125;&#125; 实例5：配置多环境不管是YML还是properties，都是在resources目录下新建3配置文件，分别表述测试环境（-dev）、生产环境（-prod）和主配置文件。通过主配置文件设置当前活动环境。 1spring.profiles.active=dev 可以在运行JAR包时指定配置文件。如果要在启动时指定使用pro配置文件，则可以输入以下 1java -jar name.jar --spring.profile.active=prod 九、常用的starterSpringboot学习笔记02一、使用Thymeleaf1、引入依赖 1&lt;!-- thyemleaf依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2、在模板中加入解析 xmlns:th=”http://www.thymeleaf.org&quot; 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;$&#123;article.title&#125;&quot;&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=&quot;$&#123;article.title&#125;&quot;&gt;标题&lt;/div&gt;&lt;div th:text=&quot;$&#123;article.body&#125;&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、配置视图解析器 Springboot某人的页面映射路径（即模板文件存放的位置）为“classpath:/templates/*.html”。静态文件路径为“classpath:/static/”,其中可以存放层叠样式表CSS、JS等模板共用的静态文件。 1# 配置Thyemleaf模板解析器属性# 代表thymeleaf模式.由于thymeleaf检查HTML格式很严格，禁止这种严格的语法检查模式spring.thymeleaf.mode=LEGACYHTML5# 代表thymeleaf模式spring.thymeleaf.encoding=UTF-8# 代表文档类型spring.thymeleaf.servlet.content-type=text/html# 为了便于测试，在开发时需要关闭缓存spring.thymeleaf.cache=false 二、thymeleaf基础语法usingthymeleaf.pdf 实例6：编写Thymeleaf视图以展示数据1//MVC模式的控制器@Controller //标注此控制器为MVC模式的控制器public class HelloWorldMvcController &#123; @RequestMapping(&quot;/helloWorld&quot;) //标注方法的URL映射路径“/helloWorld” public String helloWorld(Model model) throws Exception&#123; model.addAttribute(&quot;mav&quot;,&quot;Hello,Spring Boot!我是MVC结构！&quot;); //视图（view）的位置和名称。视图位于example文件夹下，视图文件为hello.html return &quot;example/hello&quot;; &#125;&#125; 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;$&#123;mav&#125;&quot;&gt;mav&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;container&quot;&gt;&lt;h1 th:text=&quot;$&#123;mav&#125;&quot;&gt;mav&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 三、使用控制器1、常用注解及URL映射（窄化映射）注解@RequestMapping可以在类和方法上使用。如果在类上使用，则可以窄化映射。 1@RestController@RequestMapping(&quot;news&quot;)public class NewsController()&#123; //GET方式 @RequestMapping(value=&quot;/&quot;,method=RequestMethod.GET) public void add()&#123;&#125; //POST方式 @RequestMapping(value=&quot;/&quot;,method=RequestMethod.POST) public void save()&#123;&#125;&#125;// GET方式访问add方法的路径：http://localhost:8090/news///POST方式访问save方法的路径：http://localhost:8090/news///@GetMapping(&quot;/&quot;)它等价于@RequestMapping(value=&quot;/&quot;,method=RequestMethod.GET)//GetMapping:处理GET请求。//@PostMapping:处理POST请求。//@DeleteMapping:处理删除请求。//PutMapping:处理修改请求。 2、处理HTTP请求的方法RequestMapping的method类型有GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE。可以通过这些method来处理前端用不同方法提交的数据。 GET：获取资源，如以下代码用GET方法根据id来获取文章对象。 1@GetMapping(&quot;/&#123;id&#125;&quot;)public ModelAndView getArticle(@PathVariable(&quot;id&quot;) Integer id) throws Exception&#123; Article articles = articleRepository.findNyId(id); ModelAndView mav = new ModelAndView(&quot;article/show&quot;); mav.addObject(&quot;article&quot;,articles); return mav;&#125; DELETE：在使用Restful风格则需要使用DELETE方法。在使用DELETE方法删除资源时，要注意判断是否成功，因为返回VOID类型。 一般有一下三种方法进行判断： 使用try catch exception：如果不发生异常，则默认为成功，但是这样并不好。 通过存储过程返回值来判断是否正确执行：如果执行成功，则返回1或在大于0 的值；如果执行失败，则返回0. 在执行DELETE方法前先查询是否有数据：在执行DELETE方法后返回值是0，所以，一般先查询一下是否有数据。 POST：如果需要添加对象，那一般使用POST方法传递一个Model对象。 PUT：如果对象需要更新，则用PUT方法发送请求。 PATCH：是一个新引入的方法，是对PUT方法的补充，用来对已知资源进行局部更新。 OPTIONS：该方法用于获取当前URL。若请求成功，则会在HTTP头中包含一个名为“Allow”的头，其值是所支持的方法，如值为“GET，POST”。它还允许客户端查看服务器的性能。如果遇到“500错误”，则OPTIONS不进行第二次请求。 TRACE：它显示服务器收到的请求，主要用于测试或诊断。 3、处理内容类型3.1、认识HTTP中的媒体类型Content-Type（1）常见的媒体格式如下： text/html：HTML格式 text/plain：纯文本格式 text/xml：XML格式 image/gif：GIF图片格式 image/jpeg：JPG图片格式 image/png：PNG图片格式 （2）以application开头的媒体格式如下： application/xhtml+xml：XHTML+XML格式 application/xml：XML数据格式 application/atom+xml：Atom XML聚合格式 application/json：JSON数据格式 application/pdf：PDF格式 application/msword：Word文档格式 application/octet-stream：二进制流数据（常用于文件下载） application/x-www-form-urlencoded：表单数据编码方式，只默认的ecType，form(表单)数据被默认编码为key/value格式发送给服务器。 multipart/from-data：如果在表单中进行文件上传，则需要使用该格式 3.2、使用Produces和Consumes处理内容类型（1）Produces的例子 1@RestController@RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.GET,produces=&quot;appliction/json&quot;) //返回json的话可以省略produces属性，因为RestController就是返回jsonpublic Mdoel getModel(@PathVariable String id, Model model)&#123; //&#125; 如果要强制返回编码，则加上编码类型 1produces = &quot;MediaType.APPLICATION_JSON_VALUE&quot;+&quot;;charset=utf-8&quot;) （2）Consumes的例子 在以下例子中，Consumes是消费者，用于指定获取消费者的数据类型。 1@RestController@RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.POST,produces=&quot;appliction/json&quot;) //返回json的话可以省略produces属性，因为RestController就是返回jsonpublic void addModel(@RequestBody Model model)&#123; //&#125; 3.3、在方法中使用参数1、获取路径中的值 1/** * Description: 根据id获取文章对象 * http://localhost/article/123 * 程序获取路径中123的值 */@GetMapping(&quot;article/&#123;id&#125;&quot;)public ModelAndView getArticle(@PathVariable(&quot;id&quot;) Integer id)&#123; Article articles = articleRepository.findById(id); ModelAndView mav = new ModelAndView(&quot;article/show&quot;); mav.addObject(&quot;article&quot;,articles); return mav;&#125; 2、获取路径中的参数 对于路径中的参数获取，可以写入方法的形参中。下面代码是获取参数username的值 1@RequestMapping(&quot;/addUser&quot;)public String addUser(String username)&#123; &#125;//这里的参数和上面所讲的获取路径值是不一样的，比如http://localhost/user/?username=zhaoyao，它是由“=”隔开的 3、通过Bean接收HTTP提交的对象 1public Stirng addUser(UserModel user) 4、用注解@ModelAttribute获取参数 用于从Model、Form或URL请求参数中获取属性值 1@RequestMapping(value=&quot;/addUser&quot;,method=RequestMethod.POST)public String addUser(@ModelAttribute(&quot;user&quot;) UserMdoel user) 5、通过HttpServletRequest接收参数 1@RequestMapping(&quot;/addUser&quot;)public String addUser(HttpServletRequest request)&#123; System.out.println(&quot;name:&quot;+request.GETParameter(&quot;username&quot;)); return &quot;/index&quot;;&#125; 6、用@RequestParam绑定入参 1//当请求参数不存在时会有异常发生，可以通过设置属性“required=false”来解决@RequestParam(value=&quot;username&quot;,required=false) 7、用@RequestBody接收JSON数据 1@RequestMapping(value=&quot;adduser&quot;,method=&#123;RequestMethod.POST&#125;)@ResponseBodypublic void saveUser(@RequestBody List&lt;User&gt; users)&#123; &#125; 8、上传文件MultipartFile 通过@RequestParam获取文件 1public String singleFileUpload(@RequestParam(&quot;file&quot;)MultipartFile file, RedireAttributes redireAttributes)&#123; if(file.isEmpty())&#123; redireAttributes.addFlashAttribute(&quot;message&quot;,&quot;请选择文件&quot;); return &quot;redirect:uploadStatus&quot;; &#125; try&#123; byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOAD_FOLDER+file.getOriginalFilename()); Files.write(path,bytes); redireAttributes.addFlashAttribute(&quot;message&quot;,&quot;成功上传 &quot; + file.getOriginalFilename() + &quot;&quot;); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; return &quot;redirect:/uploadStatus&quot;;&#125;//出于安全考虑，在生产环境中需要判断文件的类型，一般不允许上传“exe”等格式的可执行文件 9、上传图片 这里以常用的CKEditor4.10.1为例，实现上传图片功能。 1long l=System.currentTimeMillis();//新建日期对象Date date= new Date(l)；//转换日期输出格式SimpleDateFromat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);String nyr = dateFormat.format(date);private static String UPLOADED_FOLDER=&quot;/UPLOADED/img/&quot;;@PostMapping(&quot;/upload&quot;)@ResponseBody//注意，ckeditor上传的是upload字段public Map&lt;String,Object&gt; singleFileUpload(@RequestParam(&quot;upload&quot;) MultipartFile file, RedirectAttributes redirectAttributes)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); if(file.getOriginalFilename().endsWith(&quot;.jpg&quot;) || file.getOriginalFilename().endsWith(&quot;.png&quot;) || file.getOriginalFilename().endsWith(&quot;.gif&quot;) )&#123; try&#123; byte[] bytes = file.getBytes(); String S = nyr + Math.random() + file.getOriginalFilename(); Path path = Paths.get(UPLOADED_FOLDER + S); Files.write(path,bytes); map.put(&quot;uploaded&quot;,1); map.put(&quot;fileName&quot;,S); map.put(&quot;url&quot;,&quot;/UPLOAD/img/&quot;+S); map.put(&quot;message&quot;,&quot;上传成功&quot;); return map; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; else&#123; map.put(&quot;uploaded&quot;,0); map.put(&quot;fileName&quot;.file.getOriginalFilename()); map.put(&quot;url&quot;,&quot;/img/&quot;+file.getOriginalFilename()); map.put(&quot;message&quot;,&quot;图片后缀只支持png,jpg,gif,请检查！&quot;); return map; &#125; return map;&#125; 3.4、实例7:实现MVC模式的Web应用程序 添加依赖 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 创建实体模型 1@Datapublic class User &#123; //定义id private long id; //定义用户名 private String name; //定义年龄 private int age;&#125; 创建控制器 1@Controllerpublic class UserController &#123; //映射URL地址 @GetMapping(&quot;/user&quot;) public ModelAndView user()&#123; //实例化对象 User user= new User(); user.setName(&quot;zhaoyao&quot;); user.setAge(29); //定义MVC中的视图模板 ModelAndView modelAndView = new ModelAndView(&quot;user&quot;); //传递user实体对象给视图 modelAndView.addObject(&quot;user&quot;,user); return modelAndView; &#125;&#125; 创建用于展示的视图 1&lt;!DOCTYPE html&gt;&lt;!--thymeleaf模板支持--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;!--显示由控制器传递过来的实体user的值--&gt; &lt;!--/*@thymesVar id=&quot;user&quot; type=&quot;&quot;*/--&gt; &lt;div th:text=&quot;$&#123;user.name&#125;&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.5、实例8：验证表单数据并实现数据的自定义验证具体查看个人码云上项目名称thymeleaf springboot学习笔记03一、响应式编程1、响应式Web框架WebFlux。WebFlux可以在资源有限的情况下提高系统的吞吐量和伸缩性（不是提高性能）。这意味着，在资源相同的情况下，WebFlux可以处理更多的请求（不是业务）。 2、总结：MVC能满足的场景，就不需要改用WebFlux。WebFlux和MVC可以混合使用。如果开发I/O密集型服务，则可以选择用WebFlux实现。 3、如果在pom.xml文件中同时引用了spring-boot-starter-web和spring-boot-starter-webflux依赖，则优先使用spring-boot-starter-web。控制台输出的启动日志会提示“Tomcat started on port(s):….”，而使用WebFlux会提示“Netty started on port”。 4、Flux 和 Mono 是异步编程框架 Reactor 中的两种基本类型，而Spring Webflux 是基于 Reactor 构建的。Flux 表示空或多个结果，Mono 表示空或一个结果。两者可以进行转换，对一个Flux序列进行计数操作时，得到的结果是一个Mono对象。把多个Mono序列合并在一起，得到的是一个Flux对象。 5、开发WebFlux的流程 响应式开发流程 创建Handler类。这里的Handler类相当于Spring MVC的Controller层中的方法体。在响应式编程中，请求和响应不再是HttpServletRequest和HttpServletResponse，而是编程了ServerRequest和ServerResponse。 配置RouterFunction。RouterFunction和注解@RequestMapping相似，都用于提供URL路径。RouterFunction的格式也是固定的，第1个参数代表路径，第2个参数代表方法，合起来代表将URL映射到方法。 注解式开发流程 注解式开发方式只是Spring团队为了更好地迁移而提供的。和MVC开发模式一样，地址映射也是通过@RequestMapping提供的，用@Controller或@Restcontroller来代替Handler类。 由于个人对WebFlux的需求不大，此框架实例代码不做笔记，仙剑实例9、10、11见个人码云。 二、实例12：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询功能 1、下载安装MongoDB 4.4.4 以及oto 3T -1.42、创建用户名、密码及数据库表1--打开mongo.exe,切换到adminuse admin--创建用户名、密码和角色 db.createUser(&#123;user:&quot;geiao&quot;,pwd:&quot;1163117842@qqcom&quot;,roles:[&quot;root&quot;]&#125;) db.changeUserPassword(&#123;user:&quot;geiao&quot;,pwd:&quot;123456789&quot;,roles:[&quot;root&quot;]&#125;) 3、pom.xml添加依赖1&lt;!-- MongoDB--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;&lt;/dependency&gt; 4、配置文件中添加连接1# MongoDB spring.data.mongodb.uri=mongodb://用户名：密码@ip地址:端口号/数据库spring.data.mongodb.uri=mongodb://geiao:1163117842@qqcom@localhost:27017/test 5、entity→User.java1@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; //定义主键id private String id; //定义用户名 @NotBlank(message = &quot;用户名不能为空&quot;) @Length(min = 5,max = 20, message=&quot;用户名称长度为5-20个字符&quot;) private String name; //定义年龄 @NotNull(message = &quot;年龄不能为空&quot;) @Min(value = 18,message = &quot;最小18岁&quot;) @Max(value = 100,message = &quot;最大100岁&quot;) private Integer age; @Email(message = &quot;请输入邮箱&quot;) @NotBlank(message = &quot;邮箱不能为空&quot;) private String email; @MyConstraint private String answer;&#125; 6、repository→UserRepository.java1public interface UserRepository extends ReactiveMongoRepository&lt;User, String&gt; &#123;&#125; 7、controller→UserWebFluxController1@RestController@RequestMapping(path = &quot;/userWebFlux&quot;)public class UserWebFluxController &#123; @Autowired private UserRepository userRepository; @GetMapping(&quot;/listMongoDB&quot;) public Flux&lt;User&gt; getAll()&#123; return userRepository.findAll(); &#125; //启动测试就可以发现查询是一个一个出来的，而不是一下返回。 @GetMapping(value = &quot;/listdelay&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Flux&lt;User&gt; getAlldelay()&#123; return userRepository.findAll().delayElements(Duration.ofSeconds(1)); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(@PathVariable String id) &#123; return userRepository.findById(id) .map(getUser -&gt; ResponseEntity.ok(getUser)) .defaultIfEmpty(ResponseEntity.notFound().build()); &#125; @PostMapping(&quot;&quot;) public Mono&lt;User&gt; createUser(@Valid User user)&#123; return userRepository.save(user); &#125; @PutMapping(&quot;/&#123;id&#125;&quot;) public Mono updateUser(@PathVariable(value = &quot;id&quot;) String id, @Valid User user)&#123; return userRepository.findById(id) .flatMap(existingUser -&gt;&#123; existingUser.setName(user.getName()); return userRepository.save(existingUser); &#125;) .map(updateUser -&gt; new ResponseEntity&lt;&gt;(updateUser, HttpStatus.OK)) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(@PathVariable(value = &quot;id&quot;) String id)&#123; return userRepository.findById(id) .flatMap(existingUser -&gt; userRepository.delete(existingUser) .then(Mono.just(new ResponseEntity&lt;Void&gt;(HttpStatus.OK))) ) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125;&#125; 8、测试接口 根据id查询 1http://localhost:8090/userWebFlux/6066c330945856c2309af2b6 新增测试 1localhost:8090/userWebFlux?id=1&amp;name=geiao1&amp;age=21&amp;email=1111111@qq.com&amp;answer=北京 根据Id更新数据 1localhost:8090/userWebFlux/6066c330945856c2309af2b6?id=&quot;2&quot;&amp;name=zhangsan&amp;age=38&amp;email=1163117842@qq.com&amp;answer=上海","categories":[{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]},{"title":"Test","slug":"test","date":"2021-10-11T07:00:19.000Z","updated":"2021-10-11T09:04:41.715Z","comments":true,"path":"2021/10/11/test/","link":"","permalink":"https://giscloud.ltd/2021/10/11/test/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"},{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/categories/springboot/"}],"tags":[{"name":"-cas","slug":"cas","permalink":"https://giscloud.ltd/tags/cas/"},{"name":"-springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"},{"name":"springboot","slug":"springboot","permalink":"https://giscloud.ltd/tags/springboot/"}]}